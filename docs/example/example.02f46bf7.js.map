{"mappings":"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","sources":["src/reflex/common.ts","src/reflex/jsx.ts","src/reflex/component.ts","src/reflex/diff.ts","src/reflex/render.ts","node_modules/@zouloux/signal/dist/signal.es2020.mjs","src/reflex/observable.ts","src/reflex/state.ts","src/reflex/ref.ts","src/reflex/lifecycle.ts","example/example.tsx"],"sourcesContent":["import { IRef, IRefs } from \"./ref\";\nimport { ComponentInstance } from \"./component\";\n\n// ----------------------------------------------------------------------------- TYPES\n\n// Declare global JSX override hack\n// declare global {\n// \tnamespace JSX {\n//\n// \t}\n// }\n\n// ----------------------------------------------------------------------------- CONSTANTS\n\n// Name of private node types which should not be created with JSX\n\nexport const _TEXT_NODE_TYPE_NAME = \"#T\"\nexport const _ROOT_NODE_TYPE_NAME = \"#R\"\n\n// ----------------------------------------------------------------------------- ERRORS\n\n//export class ReflexError extends Error {}\n\n// ----------------------------------------------------------------------------- POLYFILLS\n\n// TODO : Into ecma-core + inline in bundle\nexport const _microtask = ( window.queueMicrotask ?? ( h => window.setTimeout( h, 0 )) )\n\n// ----------------------------------------------------------------------------- UTILS\n\n// Force a list or a lonely item to be an array with the same type\n// TODO : Into ecma-core + inline in bundle\nexport const _forceArray = <G>( item:G|G[] ):G[] => Array.isArray( item ) ? item : [ item ]\n\nexport const _typeof = (entity:any, firstLetterOfType:string) => (typeof entity)[0] == firstLetterOfType\n\nexport const _isStringOrNumber = entity => [\"s\", \"n\"].indexOf( (typeof entity)[0] ) >= 0\n\nexport function _flattenChildren ( vnode:VNode ) {\n\t// Re-assign flattened array to the original virtual node, and return it\n\treturn vnode.props.children = (vnode.props?.children?.flat() ?? [])\n}\n\n// ----------------------------------------------------------------------------- INTERNAL - CREATE COMPONENT\n\nexport type RenderDom = Element|Text\n\n// FIXME : Cannot be VNode[] in current implementation.\n// FIXME : Cannot be string in current implementation.\nexport type RenderFunction = () => VNode\nexport type FunctionalComponent = RenderFunction\nexport type ComponentReturn = RenderFunction|VNode\nexport type FactoryComponent = () => RenderFunction\nexport type ComponentFunction = FunctionalComponent|FactoryComponent\n\nexport type LifecycleHandler <GReturn = void> = (...rest) => GReturn\nexport type MountHandler = LifecycleHandler|LifecycleHandler<LifecycleHandler>\n\n// ----------------------------------------------------------------------------- JSX H / CREATE ELEMENT\n\nexport type VNodeDomType = keyof (HTMLElementTagNameMap|SVGElementTagNameMap)\nexport type InternalVNodeTypes = typeof _ROOT_NODE_TYPE_NAME | typeof _TEXT_NODE_TYPE_NAME\n\nexport interface VNodeBaseProps {\n\tchildren\t?:VNode[],\n\tkey\t\t\t?:string\n\tref\t\t\t?:IRef|IRefs\n\tpure\t\t?:boolean\n}\n\nexport interface VNode <\n\tGProps \t= VNodeBaseProps,\n\tGType \t= ( VNodeDomType | InternalVNodeTypes | ComponentFunction ),\n> {\n\ttype\t\t\t:GType\n\tprops\t\t\t:GProps\n\tkey\t\t\t\t:string\t// Allow numbers ?\n\tdom\t\t\t\t?:RenderDom\n\t_keys\t\t\t?:Map<string, VNode>\n\t_ref\t\t\t?:IRef | IRefs\n\t_component\t\t?:ComponentInstance\n\t_keep\t\t\t?:boolean\n\t_id\t\t\t\t?:number\n}\n\nexport interface VTextNode extends VNode<{value:string}> {\n\ttype\t\t: typeof _TEXT_NODE_TYPE_NAME\n}\n\nexport type VNodeOrVNodes = VNode|VNode[]\n","import { _isStringOrNumber, _TEXT_NODE_TYPE_NAME, VNode } from \"./common\";\n\n// NOTE : Keep it in a function and do not inline this\n// It seems to be V8 optimized. @see Preact source code\nexport function _createVNode ( type, props, key?, ref? ):VNode {\n\treturn { type: type, props: props, key: key, _ref: ref }\n}\n\nexport function _cloneVNode ( vnode:VNode ) {\n\treturn {\n\t\t...vnode,\n\t\t// IMPORTANT : also clone props object\n\t\tprops: { ...vnode.props }\n\t}\n}\n\n\nexport function h ( type, props, ...children ) {\n\t// Remove debug properties\n\t// FIXME : Keep them in debug mode ? But in vnode not in props.\n\tlet nodeProps:any = {}\n\tlet key, ref\n\tif ( props ) {\n\t\tfor ( let i in props ) {\n\t\t\tconst value = props[ i ]\n\t\t\t// Set apart key and ref\n\t\t\tif ( i == \"key\" )\n\t\t\t\tkey = value\n\t\t\telse if ( i == \"ref\" )\n\t\t\t\tref = value\n\t\t\t// Remove __self and __source debug props\n\t\t\telse if ( !i.startsWith('__') )\n\t\t\t\tnodeProps[i] = value\n\t\t}\n\t\t// Append children props into children array\n\t\tif ( _isStringOrNumber(props.children) )\n\t\t\tchildren.push( props.children )\n\t\telse if ( Array.isArray(props.children) )\n\t\t\tchildren.concat( props.children )\n\t}\n\t// Inject children in props and override\n\tnodeProps.children = children.map( child => (\n\t\t// Convert string and number children to text virtual nodes\n\t\t_isStringOrNumber(child)\n\t\t? _createVNode( _TEXT_NODE_TYPE_NAME, { value: '' + child })\n\t\t// Otherwise keep child generated by JSX\n\t\t: child\n\t))\n\treturn _createVNode( type, nodeProps, key, ref )\n}\n\n\n\n// export function h ( type, props, ...children ) {\n// \t// Remove debug properties\n// \t// FIXME : Keep them in debug mode ? But in vnode not in props.\n// \tdelete props.__self\n// \tdelete props.__source\n// \t// Extract key and ref from props\n// \tconst { key, ref, ...nodeProps } = props\n// \t// Inject children in props\n// \tnodeProps.children = ( children ?? [] ).map( child => (\n// \t\t// Convert string and number children to text virtual nodes\n// \t\t( [\"string\", \"number\"].indexOf( typeof child ) !== -1 )\n// \t\t\t? createVNode( _TEXT_NODE_TYPE_NAME, { value: child + '' })\n// \t\t\t// Otherwise keep child generated by JSX\n// \t\t\t: child\n// \t))\n// \treturn createVNode( type, nodeProps, key, ref )\n// }","import {\n\tComponentFunction, _flattenChildren, LifecycleHandler,\n\tMountHandler, RenderFunction,\n\t_TEXT_NODE_TYPE_NAME, VNode, _typeof\n} from \"./common\";\nimport { IStateObservable } from \"@zouloux/signal\";\n\n// ----------------------------------------------------------------------------- TYPES\n\nexport interface ComponentInstance { // FIXME : Generics ?\n\tvnode\t\t\t\t:VNode<null, ComponentFunction>\n\tname\t\t\t\t:string\n\tisFactory\t\t\t?:boolean\n\tisMounted\t\t\t:boolean;\n\t_isDirty\t\t\t?:boolean\n\t_render\t\t\t\t?:RenderFunction\n\t_propsProxy\t\t\t?:IPropsProxy<any>\n\t_mountHandlers\t\t:MountHandler[]\n\t_renderHandlers\t\t:LifecycleHandler[]\n\t_unmountHandlers\t:LifecycleHandler[]\n\t_observables\t\t:IStateObservable<any>[]\n\t// TODO : Imperative handlers ?\n}\n\n// ----------------------------------------------------------------------------- CREATE COMPONENT INSTANCE\n\n// Optimize it in a function @see jsx.ts/createVNode()\nexport function _createComponentInstance ( vnode:VNode<null, ComponentFunction> ):ComponentInstance {\n\treturn {\n\t\tvnode,\n\t\t_propsProxy: createPropsProxy( vnode.props ),\n\t\t_isDirty: false,\n\t\tisMounted: false,\n\t\tname: vnode.type.name,\n\t\t_mountHandlers: [],\n\t\t_renderHandlers: [],\n\t\t_unmountHandlers: [],\n\t\t_observables: [],\n\t}\n}\n\n// ----------------------------------------------------------------------------- PROPS PROXY\n// Props proxy exists because we need a way to get updated props in a factory\n// component. Because factory function is executed once, props object passed\n// as first argument cannot be updated. Proxy helps us here because it will\n// allow us to mock props but with every props updated.\n// A caveat is that props is not iterable because proxy is a dynamic key / value\n// object. Not really concerning because it makes no sense to iterate over\n// a props object.\n\nexport interface IPropsProxy <GType> {\n\treadonly value:GType\n\tset ( newValue:GType ) : void\n}\n\nfunction createPropsProxy <GProps> ( props:GProps ) : IPropsProxy<GProps> {\n\tconst proxy = new Proxy({}, {\n\t\t// When request a prop, check on props object if it exists\n\t\tget ( target:{}, propName:string|symbol ):any {\n\t\t\treturn ( propName in props ? props[ propName ] : void 0 )\n\t\t},\n\t\t// Disallow set on props\n\t\tset () {\n\t\t\tif ( process.env.NODE_ENV == \"production\" ) return false\n\t\t\tthrow new Error(`Reflex - PropsProxy.set // Setting values to props manually is not allowed.`)\n\t\t}\n\t})\n\treturn {\n\t\t// Get the proxy object typed as a GProps object\n\t\tget value () { return proxy as GProps },\n\t\t// This method will set new props object (we override first argument of createPropsProxy)\n\t\tset ( newProps:GProps ) { props = newProps }\n\t}\n}\n\n// ----------------------------------------------------------------------------- MOUNT / UNMOUNT\n\nexport function _mountComponent ( component:ComponentInstance ) {\n\t// Call every mount handler and store returned unmount handlers\n\tcomponent._mountHandlers.map( handler => {\n\t\tconst mountedReturn = handler.apply( component, [] );\n\t\tif ( _typeof(mountedReturn, \"f\") )\n\t\t\tcomponent._unmountHandlers.push( mountedReturn )\n\t})\n\t// Reset mount handlers, no need to keep them\n\tcomponent._mountHandlers = []\n\tcomponent.isMounted = true;\n}\n\nexport function _unmountComponent ( component:ComponentInstance ) {\n\tcomponent._unmountHandlers.map( h => h.apply( component, [] ) )\n\tcomponent._observables.map( o => o.dispose() )\n\t// FIXME : Do we need to do this ? Is it efficient or is it just noise ?\n\t//delete component.vnode\n\t// delete component.propsProxy\n\tdelete component._mountHandlers;\n\tdelete component._renderHandlers;\n\tdelete component._unmountHandlers;\n\tdelete component._observables\n\tcomponent.isMounted = false;\n}\n\nexport function _recursivelyUpdateMountState ( node:VNode, doMount:boolean ) {\n\tif ( node.type == _TEXT_NODE_TYPE_NAME ) return\n\t_flattenChildren( node ).map( c => c && _recursivelyUpdateMountState(c, doMount) )\n\tif ( node._component )\n\t\tdoMount ? _mountComponent( node._component ) : _unmountComponent( node._component )\n}","import {\n\t_TEXT_NODE_TYPE_NAME, RenderDom, RenderFunction,\n\tVNode, VNodeDomType, VTextNode, ComponentFunction,\n\tComponentReturn, _flattenChildren, _typeof\n} from \"./common\";\nimport { _cloneVNode } from \"./jsx\";\nimport { IInternalRef } from \"./ref\";\nimport { ComponentInstance, _createComponentInstance, _recursivelyUpdateMountState } from \"./component\";\n\n/**\n * TODO : Errors\n * - Disallow a component render function to return a component as main node !\n * \t\t\t() => <OtherComponent /> <- Forbidden\n * - Disallow a component which render an array\n * \t\t\t() => [<div />, <div />] <- Forbidden\n */\n\n// ----------------------------------------------------------------------------- CONSTANTS\n\n// Virtual node object is injected into associated dom elements with this name\nexport const _DOM_PRIVATE_VIRTUAL_NODE_KEY = \"__v\"\n\n// Attached listeners to a dom element are stored in this array\nexport const _DOM_PRIVATE_LISTENERS_KEY = \"__l\"\n\n// Stolen from Preact, to check if a style props is non-dimensional (does not need to add a unit)\nconst _IS_NON_DIMENSIONAL_REGEX = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n\n// Check if an event is a capture one\nconst _CAPTURE_REGEX = /Capture$/\n\n// ----------------------------------------------------------------------------- CURRENT SCOPED COMPONENT\n\n// We store current component in factory phase for hooks\nlet _hookedComponent:ComponentInstance = null\nexport function getHookedComponent ():ComponentInstance {\n\tif ( !_hookedComponent && process.env.NODE_ENV !== \"production\" )\n\t\t// throw new ReflexError(`getHookedComponent // Cannot use a factory hook outside of a factory component.`)\n\t\tthrow new Error(`Reflex - getHookedComponent // Cannot use a factory hook outside of a factory component.`)\n\treturn _hookedComponent\n}\n\n// ----------------------------------------------------------------------------- COMMON\n\nfunction getEventNameAndKey ( name:string, dom:Element ) {\n\t// Note : Capture management stolen from Preact, thanks\n\tconst useCapture = name !== ( name = name.replace(_CAPTURE_REGEX, '') );\n\t// Infer correct casing for DOM built-in events:\n\tconst eventName = ( name.toLowerCase() in dom ? name.toLowerCase() : name ).slice(2)\n\t// Create unique key for this event\n\tconst eventKey = eventName + (useCapture ? 'C' : '')\n\treturn { eventName, eventKey, useCapture }\n}\n\n// Stolen from Preact, attach some style à key / value to a dom element\nfunction setStyle ( style:CSSStyleDeclaration, key:string, value:string|null ) {\n\tif (key[0] === '-')\n\t\tstyle.setProperty(key, value);\n\telse if (value == null)\n\t\tstyle[key] = '';\n\t// FIXME : IS_NON_DIMENSIONAL_REGEX -> Is it really necessary ?\n\telse if ( !_typeof(value, \"n\") || _IS_NON_DIMENSIONAL_REGEX.test(key) )\n\t\tstyle[key] = value;\n\telse\n\t\tstyle[key] = value + 'px';\n}\n\nfunction updateNodeRef ( node:VNode ) {\n\tnode._ref && ( node._ref as IInternalRef )._setFromVNode( node as any )\n}\n\n// Shallow compare two objects, applied only for props between new and old virtual nodes.\n// Will not compare \"children\" which is always different\n// https://esbench.com/bench/62a138846c89f600a5701904\nconst shallowPropsCompare = ( a:object, b:object ) => (\n\t// Same amount of properties ?\n\tObject.keys(a).length === Object.keys(b).length\n\t// Every property exists in other object ?\n\t// Never test \"children\" property which is always different\n\t&& Object.keys(a).every( key => key === \"children\" || (b.hasOwnProperty(key) && a[key] === b[key]) )\n)\n\n// ----------------------------------------------------------------------------- DIFF ELEMENT\n\nexport function _diffElement ( newNode:VNode, oldNode:VNode ) {\n\t// console.log(\"diffElement\", newNode, oldNode)\n\tconst isTextNode = newNode.type == _TEXT_NODE_TYPE_NAME\n\t// Get dom element from oldNode or create it\n\tconst dom:RenderDom = (\n\t\toldNode ? oldNode.dom : (\n\t\t\tisTextNode\n\t\t\t? document.createTextNode( (newNode as VTextNode).props.value )\n\t\t\t: document.createElement( newNode.type as VNodeDomType )\n\t\t)\n\t)\n\t// Update text contents\n\tif ( isTextNode && oldNode ) {\n\t\tconst { value } = (newNode as VTextNode).props;\n\t\t// Only when content has changed\n\t\tif ( value != (dom as Text).nodeValue )\n\t\t\t( dom as Text ).nodeValue = value\n\t}\n\t// Text nodes does not have attributes or events\n\tif ( isTextNode ) return dom\n\t// Remove attributes which are removed from old node\n\toldNode && Object.keys( oldNode.props ).map( name => {\n\t\t// Do not process children and remove only if not in new node\n\t\tif ( name == \"children\" ) return\n\t\tif ( name in newNode.props && newNode.props[ name ] === oldNode.props[ name ] )\n\t\t\treturn\n\t\t// Insert HTML directly without warning\n\t\tif ( name == \"innerHTML\" )\n\t\t\t( dom as Element ).innerHTML = \"\" // FIXME : Maybe use delete or null ?\n\t\t\t// Events starts with \"on\". On preact this is optimized with [0] == \"o\"\n\t\t// But recent benchmarks are pointing to startsWith usage as faster\n\t\telse if ( name.startsWith(\"on\") ) {\n\t\t\tconst { eventName, eventKey, useCapture } = getEventNameAndKey( name, dom as Element );\n\t\t\tdom.removeEventListener( eventName, dom[ _DOM_PRIVATE_LISTENERS_KEY ][ eventKey ], useCapture )\n\t\t}\n\t\t// Other attributes\n\t\telse {\n\t\t\t( dom as Element ).removeAttribute( name )\n\t\t}\n\t})\n\t// Update props\n\tObject.keys( newNode.props ).map( name => {\n\t\tif ( name == \"children\" ) return\n\t\tlet value = newNode.props[ name ];\n\t\t// Do not continue if attribute or event did not change\n\t\tif ( oldNode && name in oldNode.props && oldNode.props[ name ] === value )\n\t\t\treturn;\n\t\t// Insert HTML directly without warning\n\t\tif ( name == \"innerHTML\" )\n\t\t\t( dom as Element ).innerHTML = value\n\t\t// Events starts with \"on\". On preact this is optimized with [0] == \"o\"\n\t\t// But recent benchmarks are pointing to startsWith usage as faster\n\t\telse if ( name.startsWith(\"on\") ) {\n\t\t\tconst { eventName, eventKey, useCapture } = getEventNameAndKey( name, dom as Element );\n\t\t\t// Init a collection of handlers on the dom object as private property\n\t\t\tdom[ _DOM_PRIVATE_LISTENERS_KEY ] ??= new Map();\n\t\t\t// Store original listener to be able to remove it later\n\t\t\tdom[ _DOM_PRIVATE_LISTENERS_KEY ][ eventKey ] = value;\n\t\t\t// And attach listener\n\t\t\tdom.addEventListener( eventName, value, useCapture )\n\t\t}\n\t\t// Other attributes, just set right on the dom element\n\t\telse {\n\t\t\t// className as class for non jsx components\n\t\t\tif ( name == \"className\" )\n\t\t\t\tname = \"class\"\n\t\t\t// Manage class as arrays\n\t\t\tif ( name == \"class\" && Array.isArray( value ) )\n\t\t\t\tvalue = value.filter( v => v !== true && !!v ).join(\" \").trim()\n\t\t\t// Manage style as object only\n\t\t\telse if ( name == \"style\" && _typeof(value, \"o\") )\n\t\t\t\t// FIXME : Can it be optimized ? Maybe only setStyle when needed ?\n\t\t\t\treturn Object.keys( value ).map(\n\t\t\t\t\tk => setStyle( (dom as HTMLElement).style, k, value[k] )\n\t\t\t\t);\n\t\t\t// Remove falsy values\n\t\t\telse if ( value == false )\n\t\t\t\treturn;\n\t\t\t// FIXME : What about checked / disabled / autoplay ...\n\t\t\t// Set new attribute value if not undefined\n\t\t\t// FIXME : Add only if truey ?\n\t\t\t// if ( typeof value < \"u\" )\n\t\t\tif ( value )\n\t\t\t\t( dom as Element ).setAttribute( name, value )\n\t\t}\n\t})\n\treturn dom;\n}\n\n// ----------------------------------------------------------------------------- DIFF CHILDREN\n\n/**\n * Note about performances\n * - Very important, avoid loops in loops ! Prefer 4 static loops at top level\n *   rather than 2 nested loops. n*4 is lower than n^n !\n */\nexport function _diffChildren ( newParentNode:VNode, oldParentNode?:VNode ) {\n\t// console.log(\"Diff children\", newParentNode, oldParentNode)\n\t// Target new and old children.\n\tconst newChildren = newParentNode.props.children?.flat()\n\tconst oldChildren = oldParentNode?.props.children?.flat()\n\t// FIXME : If new does not have children but old does, we need to destroy old children components instances\n\tif ( !newChildren ) return;\n\tconst parentDom = newParentNode.dom as Element\n\t// Create key array on parent node to register keyed children\n\t// This will allow us to find any child by its key directly without\n\t// having to search for it\n\tnewParentNode._keys = new Map()\n\tconst registerKey = c => {\n\t\tif ( c?.key ) newParentNode._keys[ c.key ] = c\n\t}\n\t// This is a new parent node (no old), so no diffing\n\t// we juste process and add every child node\n\tif ( !oldChildren ) {\n\t\tnewChildren.map( newChildNode => {\n\t\t\tif (!newChildNode) return;\n\t\t\t_diffNode( newChildNode )\n\t\t\tparentDom.appendChild( newChildNode.dom )\n\t\t\t// Register this child with its key on its parent\n\t\t\tregisterKey( newChildNode )\n\t\t})\n\t\treturn;\n\t}\n\t// Map all new children keys into the keys register to avoid to use find\n\t// when searching for removed nodes\n\t// NOTE : About performances : 1st non-nested loop\n\tnewChildren.map( registerKey )\n\t// Check if an old keyed node has been removed and get which index are offset after removal\n\t// NOTE : About performances : 2nd non-nested loop\n\tconst lostIndexes = oldChildren.map(\n\t\toldChild => !!(oldChild?.key && !newParentNode._keys[oldChild.key] )\n\t)\n\t// Otherwise we need to compare between old and new tree\n\tconst oldParentKeys = oldParentNode._keys\n\tlet collapseCount = 0\n\t// NOTE : About performances : 3rd non-nested loop\n\tnewChildren.map( (newChildNode, i) => {\n\t\t// Collapsed corresponding index between old and new nodes\n\t\t// To be able to detect moves or if just collapsing because a top sibling\n\t\t// has been removed\n\t\tif ( lostIndexes[i] )\n\t\t\tcollapseCount ++\n\t\t/** REMOVED **/\n\t\t// If falsy, it's surely a child that has been removed with a ternary or a boolean\n\t\t// Do nothing else and do not mark old node to keep, so it will be removed\n\t\tif ( !newChildNode )\n\t\t\treturn;\n\t\t// Has key, same key found in old, same type on both\n\t\t/** MOVE & UPDATE KEYED CHILD **/\n\t\tif (\n\t\t\tnewChildNode.key\n\t\t\t&& oldParentKeys[ newChildNode.key ]\n\t\t\t&& oldParentKeys[ newChildNode.key ].type == newChildNode.type\n\t\t) {\n\t\t\tconst oldNode = oldParentKeys[ newChildNode.key ]\n\t\t\t_diffNode( newChildNode, oldNode )\n\t\t\toldNode._keep = true;\n\t\t\t// Check if index changed, compare with collapsed index to detect moves\n\t\t\tconst collapsedIndex = i + collapseCount\n\t\t\t// FIXME : Should do 1 operation when swapping positions, not 2\n\t\t\t// FIXME : Perf, is indexOf quick ? Maybe store every indexes in an array ?\n\t\t\tif ( oldChildren.indexOf( oldNode ) != collapsedIndex )\n\t\t\t\tparentDom.insertBefore( newChildNode.dom, parentDom.children[ i ] )\n\t\t}\n\t\t// Has key, but not found in old\n\t\t/** CREATE **/\n\t\telse if ( newChildNode.key && !oldParentKeys[ newChildNode.key ] ) {\n\t\t\t_diffNode( newChildNode )\n\t\t\tparentDom.insertBefore( newChildNode.dom, parentDom.children[ i ] )\n\t\t\tcollapseCount --\n\t\t}\n\t\t// Found at same index, with same type.\n\t\t// Old node does not have a key.\n\t\t/** UPDATE IN PLACE **/\n\t\telse if ( i in oldChildren && oldChildren[ i ] && oldChildren[ i ].type == newChildNode.type ) {\n\t\t\tconst oldNode = oldChildren[ i ]\n\t\t\t_diffNode( newChildNode, oldNode )\n\t\t\toldNode._keep = true;\n\t\t}\n\t\t// Not found\n\t\t/** CREATE **/\n\t\telse {\n\t\t\t_diffNode( newChildNode )\n\t\t\tparentDom.insertBefore( newChildNode.dom, parentDom.children[ i ] )\n\t\t\tcollapseCount --\n\t\t}\n\t})\n\t// Remove old children which are not reused\n\t// NOTE : About performances : 4th non-nested loop\n\toldChildren.map( oldChildNode => {\n\t\tif ( oldChildNode && !oldChildNode._keep ) {\n\t\t\t// Call unmount handlers\n\t\t\t_recursivelyUpdateMountState( oldChildNode, false );\n\t\t\t// Remove ref\n\t\t\tconst { dom } = oldChildNode\n\t\t\toldChildNode.dom = null;\n\t\t\tupdateNodeRef( oldChildNode )\n\t\t\tparentDom.removeChild( dom )\n\t\t}\n\t})\n}\n\n// ----------------------------------------------------------------------------- DIFF NODE\n\nfunction renderComponentNode <GReturn = ComponentReturn> ( node:VNode<null, ComponentFunction>, component:ComponentInstance ) :GReturn {\n\t// Tie component and virtual node\n\tcomponent.vnode = node\n\tnode._component = component\n\t// Select hooked component\n\t_hookedComponent = component;\n\t// FIXME: Before render handlers ?\n\t// FIXME: Optimize rendering with a hook ?\n\t// Execute rendering\n\tconst result = (component._render ?? node.type as RenderFunction)\n\t\t.apply( component, [ component._propsProxy.value ])\n\t// Unselect hooked component\n\t_hookedComponent = null\n\treturn result as GReturn\n}\n\nexport function _diffNode ( newNode:VNode, oldNode?:VNode ) {\n\t// IMPORTANT : Here we clone node if we got the same instance\n\t// \t\t\t   Otherwise, altering props.children after render will fuck everything up\n\t// Clone identical nodes to be able to diff them\n\tif ( oldNode && oldNode === newNode )\n\t\tnewNode = _cloneVNode( oldNode )\n\t// Transfer component instance from old node to new node\n\tlet component:ComponentInstance = oldNode?._component\n\t// Transfer id\n\tif ( oldNode && oldNode._id )\n\t\tnewNode._id = oldNode._id\n\t// We may need a new component instance\n\tlet renderResult:VNode\n\tif ( !component && _typeof(newNode.type, \"f\") ) {\n\t\t// Create component instance (without new keyword for better performances)\n\t\tcomponent = _createComponentInstance( newNode as VNode<null, ComponentFunction> )\n\t\t// Execute component's function and check what is returned\n\t\tconst result = renderComponentNode( newNode as VNode<null, ComponentFunction>, component )\n\t\t// This is a factory component which return a render function\n\t\tif ( _typeof(result, \"f\") ) {\n\t\t\tcomponent._render = result as RenderFunction\n\t\t\tcomponent.isFactory = true\n\t\t}\n\t\t// This is pure functional component which returns a virtual node\n\t\telse if ( _typeof(result, \"o\") && \"type\" in result ) {\n\t\t\tcomponent._render = newNode.type as RenderFunction\n\t\t\tcomponent.isFactory = false\n\t\t\trenderResult = result\n\t\t}\n\t}\n\tlet dom:RenderDom\n\t// Virtual node is a dom element\n\tif ( !component ) {\n\t\tnewNode.dom = dom = _diffElement( newNode, oldNode )\n\t}\n\t// Virtual node is a component\n\telse {\n\t\t// FIXME : Is it a good idea to shallow compare props on every changes by component ?\n\t\t// \t\t\t-> It seems to be faster than preact + memo with this 👀, check other cases\n\t\t// TODO : Maybe do not shallow by default but check if component got an \"optimize\" function\n\t\t//\t\t\twhich can be implemented with hooks. We can skip a lot with this !\n\t\t// FIXME : Does not work if props contain dynamic arrow functions :(\n\t\t//\t\t\t<Sub onEvent={ e => handler(e, i) } />\n\t\t//\t\t\tHere the handler is a different ref at each render\n\t\t// If props did not changed between old and new\n\t\t// Only optimize pure components, factory components mau have state so are not pure\n\t\tif (\n\t\t\t// If pure functional component has not already been rendered\n\t\t\t!renderResult\n\t\t\t// Need to be a component update, on a pure functional component,\n\t\t\t&& oldNode && !component.isFactory // && !component.isDirty\n\t\t\t// New component isn't marked as not pure\n\t\t\t&& newNode.props.pure !== false // FIXME : Rename it forceRefresh={ true } ?\n\t\t\t// Cannot optimize components which have children properties\n\t\t\t// Because parent component may have altered rendering of injected children\n\t\t\t&& newNode.props.children.length === 0\n\t\t\t// Do shallow compare\n\t\t\t&& shallowPropsCompare(newNode.props, oldNode.props)\n\t\t) {\n\t\t\t// FIXME : Weirdly, it seems to optimize not all components\n\t\t\t//\t\t\tEx : click on create 1000 several times and watch next console log\n\t\t\t// console.log(\"OPTIMIZE\")\n\t\t\t// Do not re-render, just get children and dom from old node\n\t\t\t// newNode.props.children = [ ...oldNode.props.children ]\n\t\t\tnewNode.props.children = oldNode.props.children\n\t\t\tnewNode.dom = dom = oldNode.dom\n\t\t}\n\t\t// Not already rendered, and not optimization possible. Render now.\n\t\telse if ( !renderResult ) {\n\t\t\tcomponent._propsProxy.set( newNode.props )\n\t\t\trenderResult = renderComponentNode<VNode>( newNode as VNode<null, ComponentFunction>, component )\n\t\t}\n\t\t// We rendered something (not reusing old component)\n\t\tif ( renderResult ) {\n\t\t\t// Apply new children list to the parent component node\n\t\t\tnewNode.props.children = _flattenChildren( renderResult )\n\t\t\t// Diff rendered element\n\t\t\tnewNode.dom = dom = _diffElement( renderResult, oldNode )\n\t\t\t// Assign ref of first virtual node to the component's virtual node\n\t\t\tnewNode._ref = renderResult._ref\n\t\t}\n\t\t// Tie up node and component\n\t\tnewNode._component = component\n\t\tcomponent.vnode = newNode as any\n\t\t// Component is clean and rendered now\n\t\tcomponent._isDirty = false\n\t}\n\t// Update ref on node\n\tupdateNodeRef( newNode )\n\t// Diff children of this element (do not process text nodes)\n\tif ( dom instanceof Element )\n\t\t_diffChildren( newNode, oldNode )\n\t// If component is not mounted yet, mount it recursively\n\tif ( component && !component.isMounted )\n\t\t_recursivelyUpdateMountState( newNode, true )\n\t// Execute after render handlers\n\tcomponent?._renderHandlers.map( h => h() )\n}\n","import { _ROOT_NODE_TYPE_NAME, _forceArray, VNodeOrVNodes, _microtask } from \"./common\";\nimport { _diffChildren, _diffNode, _DOM_PRIVATE_VIRTUAL_NODE_KEY } from \"./diff\";\nimport { _createVNode } from \"./jsx\";\nimport { ComponentInstance } from \"./component\";\n\n// ----------------------------------------------------------------------------- RENDER\n\nexport function render ( rootNode:VNodeOrVNodes, parentElement:HTMLElement ) {\n\t// When using render, we create a new root node to detect new renders\n\t// This node is never rendered, we just attach it to the parentElement and render its children\n\tconst root = _createVNode( _ROOT_NODE_TYPE_NAME, { children: _forceArray( rootNode ) })\n\troot.dom = parentElement\n\t_diffChildren( root, parentElement[ _DOM_PRIVATE_VIRTUAL_NODE_KEY ] )\n\tparentElement[ _DOM_PRIVATE_VIRTUAL_NODE_KEY ] = root\n}\n\n// ----------------------------------------------------------------------------- INVALIDATION\n\nlet componentsToUpdate:ComponentInstance[] = []\nfunction updateDirtyComponents () {\n\tlet p\n\tif ( process.env.NODE_ENV !== \"production\" )\n\t\tp = require(\"./debug\").trackPerformances(\"Update dirty components\")\n\t// TODO : Update with depth ! Deepest first ? Or last ?\n\tcomponentsToUpdate.map( component => {\n\t\t_diffNode( component.vnode, component.vnode )\n\t})\n\tcomponentsToUpdate = []\n\tp && p();\n}\n\nexport function invalidateComponent ( component:ComponentInstance ) {\n\t// Queue rendering before end of frame\n\tif ( componentsToUpdate.length === 0 )\n\t\t_microtask( updateDirtyComponents );\n\t// Invalidate this component once\n\tif ( component._isDirty ) return;\n\tcomponent._isDirty = true\n\t// Store it into the list of dirty components\n\tcomponentsToUpdate.push( component )\n}\n\n// ----------------------------------------------------------------------------- REGISTER WEB-COMPONENTS\n\n// TODO : Web components ! Check how lit and preact webcomponents works\n//\t\t\t- Register web-components with ComponentName to <component-name />\n//  \t\t- Update properties when changed in DOM\n//  \t\t\t- Need translation (detect numbers, maybe json for array and objects ?)\n//\t\t\t\t- Maybe an API to set props with JS and with advanced type (like functions)\n//\t\t\t- Children\n//\t\t\t- DOM Find\n//\t\t\t- Mount / Unmount\n\n// ----------------------------------------------------------------------------- HYDRATE\n\n// TODO : Hydrate\n// TODO : Render to string or render to web components to avoid expensive hydratation ?\n\n","// TODO v1.1 RC\n// -> Better generic types that can leak from dispatch, without generic set at init\n// -> Better generic types which respect type order for GHP\n// ----------------------------------------------------------------------------- CLASSIC SIGNAL\nexport function Signal() {\n    // List of attached listeners\n    let _listeners = [];\n    // Remove a listener by its reference\n    const remove = (handler) => _listeners = _listeners.filter(l => l[0] !== handler);\n    // Add a listener with once and call at init parameters\n    function add(handler, once, callAtInit = false) {\n        // Add listener\n        _listeners.push([handler, once]);\n        // Call at init with parameters if callAtInit is an array of parameters\n        // Just call without parameters if callAtInit is true\n        callAtInit && handler.apply(null, Array.isArray(callAtInit) ? callAtInit : null);\n        // Return a handler which will remove this listener\n        // Very handy with React hooks like useLayoutEffect\n        return () => remove(handler);\n    }\n    // Return public API\n    return {\n        // Add and return a remove thunk\n        add(handler, callAtInit = false) {\n            return add(handler, false, callAtInit);\n        },\n        // Add once and return a remove thunk\n        once(handler) {\n            return add(handler, true);\n        },\n        remove,\n        dispatch: (...rest) => _listeners.map(listener => {\n            // Remove listener if this is a once\n            listener[1] && remove(listener[0]);\n            // Execute with parameters\n            return listener[0](...rest);\n        }),\n        clear() { _listeners = []; },\n        get listeners() { return _listeners.map(l => l[0]); }\n    };\n}\nexport default Signal;\n","import { Signal, ISignal } from \"@zouloux/signal\";\nimport { _typeof } from \"./common\";\n\n// ----------------------------------------------------------------------------- COMMON TYPES\n\nexport type TChangedHandler<GType, GReturnType = void> = ( newValue:GType, oldValue:GType) => GReturnType|Promise<GReturnType>\n\nexport type TSignalWithoutDispatch <GSignalArguments extends any[]> = Omit<ISignal<GSignalArguments>, \"dispatch\">\n\n// ----------------------------------------------------------------------------- INITIAL VALUE & SETTER\n\nexport type TInitialValue<GType> = GType | (() => GType)\nexport type TSetter<GType> = GType | ((GType) => GType)\n\nconst prepareInitialValue = <GType> ( initialValue:TInitialValue<GType> ) => (\n\t_typeof(initialValue, \"f\") ? ( initialValue as () => GType )() : initialValue as GType\n)\n\nconst executeSetter = <GType> ( currentValue:GType, setter:TSetter<GType> ):GType => (\n\t_typeof(setter, \"f\") ? (setter as ((GType) => GType))( currentValue ) : setter as GType\n)\n\n// ----------------------------------------------------------------------------- BIT\n\nexport interface IPublicBit <GType> {\n\tonChanged\t\t:TSignalWithoutDispatch<[GType, GType]>\n\tdispose \t\t() : void\n}\n\nexport interface IBit <GType> extends IPublicBit <GType> {\n\tget () : GType\n\tset ( newValue:GType ) : void\n\tdispatch ( newValue:GType, oldValue:GType ) : any|void\n}\n\n/**\n * A bit is a piece of data associated to a signal, a getter and a setter.\n * A raw bit does not dispatch the signal when set on purpose. It's meant to be\n * used by an upper function which holds dispatch as a private member.\n * @param initialValue Initial value or initial value generator.\n */\nexport function createBit <GType> ( initialValue?:TInitialValue<GType> ):IBit<GType> {\n\t// Init and store the value in this scope\n\tlet value:GType = prepareInitialValue( initialValue )\n\t// Create signal and extract dispatch method from it\n\t// So code accessing signal externally would not be able to dispatch and mess\n\tconst onChanged = Signal<[GType, GType]>()\n\tconst { dispatch } = onChanged\n\tdelete onChanged.dispatch;\n\t// Return bit API\n\treturn {\n\t\tonChanged,\n\t\tdispatch,\n\t\tget () { return value },\n\t\tset ( newValue:TSetter<GType> ) { value = executeSetter(value, newValue) },\n\t\tdispose () {\n\t\t\tonChanged.clear();\n\t\t\tvalue = null;\n\t\t}\n\t}\n}\n\n// ----------------------------------------------------------------------------- BASIC OBSERVABLE\n\nexport interface IBasicObservable <GType> extends IPublicBit <GType> {\n\treadonly value:GType\n\t// get () : GType\n\tset ( newValue:TInitialValue<GType> ) : void\n}\n\n/**\n * The simplest observable, holds a value a\tand dispatch when mutated.\n * No shallow check, no invalidation step, not cancellable.\n * Everything is synchronous.\n * Has a private _dispose method to destroy it from memory.\n * @param initialValue Initial value or initial value generator.\n */\n/*export function createBasicObservable <GType> ( initialValue?:TInitialValue<GType> ):IBasicObservable<GType> {\n\t// Create the bit and extract private dispatch and setter\n\t// const { get, set, dispatch, ...bit } = createBit<GType>( initialValue );\n\tconst bit = createBit<GType>( initialValue );\n\treturn {\n\t\t// ...bit,\n\t\tonChanged: bit.onChanged,\n\t\tdispose: bit.dispose,\n\t\tget value () { return bit.get() },\n\t\tset ( newValue:GType) {\n\t\t\tconst oldValue = bit.get();\n\t\t\tbit.set( newValue );\n\t\t\tbit.dispatch( newValue, oldValue )\n\t\t}\n\t}\n}*/\n\n// ----------------------------------------------------------------------------- STATE OBSERVABLE\n\nexport interface IStateObservable <GType> extends IBasicObservable <GType> {\n\tset ( newValue:TInitialValue<GType> ) : Promise<void>\n}\n\nexport function createStateObservable <GType> (\n\tinitialValue\t?:TInitialValue<GType>,\n\tbeforeChanged\t?:TChangedHandler<GType, boolean|void>\n):IStateObservable<GType> {\n\t// Create the bit and extract private dispatch and setter\n\t// TODO : IMPORTANT : Weirdly, we can destruct like this with tsc\n\t// \tget value () { return get() } will not work and always return initial value\n\t// const { get, set, dispatch, ...bit } = createBit<GType>( initialValue );\n\tconst bit = createBit<GType>( initialValue );\n\treturn {\n\t\t// ...bit,\n\t\tonChanged: bit.onChanged,\n\t\tdispose: bit.dispose,\n\t\t// get: bit.get,\n\t\tget value () { return bit.get() },\n\t\tasync set ( newValue:TSetter<GType> ) {\n\t\t\tconst oldValue = bit.get();\n\t\t\tnewValue = executeSetter( oldValue, newValue )\n\t\t\tbit.set( newValue );\n\t\t\tif ( beforeChanged ) {\n\t\t\t\t// isLocked = true;\n\t\t\t\tconst haltChange = await beforeChanged( newValue, oldValue )\n\t\t\t\tif ( haltChange === true ) {\n\t\t\t\t\tbit.set( oldValue );\n\t\t\t\t\t// isLocked = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// isLocked = false;\n\t\t\tbit.dispatch( newValue, oldValue );\n\t\t}\n\t}\n}\n\n// ----------------------------------------------------------------------------- ASYNC OBSERVABLE\n\nexport interface IAsyncObservable <GType> extends IStateObservable <GType> {\n\treadonly isChanging\t\t\t:boolean\n\treadonly wasAlreadyChanging\t:boolean\n}\n\nexport function createAsyncObservable <GType> (\n\tinitialValue\t?:TInitialValue<GType>,\n\tbeforeChanged\t?:TChangedHandler<GType, boolean|void>\n):IAsyncObservable<GType> {\n\t// Create the bit and extract private dispatch and setter\n\t// const { get, set, dispatch, ...bit } = createBit<GType>( initialValue );\n\tconst bit = createBit<GType>( initialValue );\n\tlet isChanging = false\n\tlet wasAlreadyChanging = false\n\treturn {\n\t\t// ...bit,\n\t\tonChanged: bit.onChanged,\n\t\tdispose: bit.dispose,\n\t\t// get: bit.get,\n\t\tget value () { return bit.get() },\n\t\tget isChanging () { return isChanging },\n\t\tget wasAlreadyChanging () { return wasAlreadyChanging },\n\t\tasync set ( newValue:TSetter<GType> ) {\n\t\t\t// Keep old to check changes\n\t\t\tconst oldValue = bit.get();\n\t\t\tnewValue = executeSetter( oldValue, newValue )\n\t\t\tbit.set( newValue )\n\t\t\t// Call private changed as async (may change state asynchronously)\n\t\t\tif ( beforeChanged ) {\n\t\t\t\tif ( isChanging )\n\t\t\t\t\twasAlreadyChanging = true\n\t\t\t\tisChanging = true;\n\t\t\t\tconst haltChange = await beforeChanged( newValue, oldValue )\n\t\t\t\tif ( haltChange === true ) {\n\t\t\t\t\tbit.set( oldValue )\n\t\t\t\t\tisChanging = false\n\t\t\t\t\twasAlreadyChanging = false\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tisChanging = false\n\t\t\t\tif ( wasAlreadyChanging ) {\n\t\t\t\t\twasAlreadyChanging = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Call public onChange signal with new and old values\n\t\t\tbit.dispatch( newValue, oldValue )\n\t\t}\n\t}\n}\n","import { getHookedComponent } from \"./diff\";\nimport { invalidateComponent } from \"./render\";\nimport {\n\tcreateAsyncObservable, createStateObservable, IAsyncObservable,\n\tIStateObservable, TInitialValue\n} from \"./observable\";\n\n// ----------------------------------------------------------------------------- STATE\n\nexport function state <GType> ( initialValue?:TInitialValue<GType> ):IStateObservable<GType> {\n\tconst component = getHookedComponent()\n\tconst observable = createStateObservable( initialValue, () => invalidateComponent( component ) )\n\tcomponent._observables.push( observable )\n\treturn observable\n}\n\n// ----------------------------------------------------------------------------- ASTNC STATE\n\nexport function asyncState <GType> ( initialValue?:TInitialValue<GType> ):IAsyncObservable<GType> {\n\tconst component = getHookedComponent()\n\t// TODO : Implement this\n\tconst observable = createAsyncObservable( initialValue, () => invalidateComponent( component ) )\n\t// TODO : We may need cancellable Promises. Maybe just use reject ? And throw errors in legacy mode.\n\tcomponent._observables.push( observable )\n\treturn observable\n}","import { VNode, VNodeBaseProps } from \"./common\";\nimport { ComponentInstance } from \"./component\";\n\n// ----------------------------------------------------------------------------- REF\n\nexport interface IRef <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n> {\n\tdom\t\t\t\t:GDom\n\tcomponent\t\t:GComponent\n}\n\nexport interface IInternalRef <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n> extends IRef {\n\t_setFromVNode\t: ( vnode:VNode<VNodeBaseProps, GComponent> ) => void\n}\n\nexport function ref <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n> ():IRef<GDom, GComponent> {\n\tconst value:IInternalRef<GDom, GComponent> = {\n\t\tcomponent: null,\n\t\tdom: null,\n\t\t_setFromVNode ( vnode:VNode<VNodeBaseProps, GComponent> ) {\n\t\t\tvalue.dom \t\t= vnode.dom as GDom;\n\t\t\tvalue.component = vnode._component as GComponent;\n\t\t}\n\t}\n\treturn value as never as IRef<GDom, GComponent>;\n}\n\n// ----------------------------------------------------------------------------- REFS\n\nexport interface IRefs <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n> {\n\tlist \t: IRef<GDom, GComponent>[]\n\tatIndex\t: (index:number) => any\n}\n\nexport interface IInternalRefs <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n> extends IRefs {\n\t_setFromVNode\t: ( vnode:VNode<VNodeBaseProps, GComponent> ) => void\n}\n\nexport function refs <\n\tGComponent extends ComponentInstance = ComponentInstance,\n\tGDom extends Element = Element,\n> ():IRefs<GDom, GComponent> {\n\tlet _counter = 0;\n\tlet _list = []\n\n\tfunction registerAtIndex ( vnode, index ) {\n\t\t// Delete\n\t\tif ( !vnode.dom )\n\t\t\t_list = _list.filter( (_, i) => i != index )\n\t\t// Create / update\n\t\t// FIXME : Check if dom change checking is necessary\n\t\t// else if ( !list[index] || list[index].dom != vnode.dom ) {\n\t\telse {\n\t\t\t_list[ index ] = {\n\t\t\t\tdom \t\t: vnode.dom as GDom,\n\t\t\t\tcomponent\t: vnode._component as GComponent,\n\t\t\t}\n\t\t}\n\n\t}\n\tconst value:IInternalRefs<GDom, GComponent> = {\n\t\tget list () { return _list },\n\t\t_setFromVNode ( vnode:VNode<VNodeBaseProps, GComponent> ) {\n\t\t\t// Set vnode id from counter.\n\t\t\t// Node ids starts from 1 to be able to compress a bit\n\t\t\tif ( !vnode._id )\n\t\t\t\tvnode._id = ++_counter\n\t\t\t// Set back from starting 1 to 0\n\t\t\tregisterAtIndex( vnode, vnode._id - 1 )\n\t\t},\n\t\t// FIXME : Better api ?\n\t\tatIndex ( index:number ) {\n\t\t\treturn {\n\t\t\t\t// TODO : Check if terser uses same mangled name\n\t\t\t\t_setFromVNode ( vnode:VNode<VNodeBaseProps, GComponent> ) {\n\t\t\t\t\tregisterAtIndex( vnode, index )\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn value as never as IRefs<GDom, GComponent>;\n}\n\n// FIXME : When using web components with original dom not from Reflex\n// FIXME : Move it in module web-components ?\n// export function find () {\n//\n// }","import { getHookedComponent } from \"./diff\";\nimport { _typeof, LifecycleHandler, MountHandler } from \"./common\";\n\n// ----------------------------------------------------------------------------- MOUNT / UNMOUNT\n\nexport function mounted ( handler:MountHandler ) {\n\t// FIXME : In dev mode, maybe check if component is mounted ?\n\tgetHookedComponent()._mountHandlers.push( handler )\n}\n\nexport function unmounted ( handler:LifecycleHandler ) {\n\t// FIXME : In dev mode, maybe check if component is mounted ?\n\tgetHookedComponent()._unmountHandlers.push( handler )\n}\n\n// ----------------------------------------------------------------------------- TRACK CHANGE AFTER RENDER\n\ntype UnmountTrackHandler <GState> = (oldState:GState) => void\ntype TrackHandler <GState> = (newState:GState, oldState:GState) => UnmountTrackHandler<GState>|void\ntype DetectChanges <GState> = () => GState\n\nexport function changed <GState extends any[]> ( detectChanges:DetectChanges<GState>|TrackHandler<GState>, executeHandler?:TrackHandler<GState> ) {\n\tconst component = getHookedComponent()\n\t// No executeHandler function means detectChanges has been omitted.\n\t// Do not check any change, just call executeHandler after every render.\n\tif ( !executeHandler ) {\n\t\tcomponent._renderHandlers.push( detectChanges );\n\t\treturn;\n\t}\n\t// Get first state\n\tlet state = (detectChanges as DetectChanges<GState>)()\n\t// Stored previous unmount handler\n\tlet previousUnmountHandler:LifecycleHandler\n\t// Update new state and call handlers\n\tfunction updateState ( oldState:GState ) {\n\t\t// Call previous handler with old state if it exists\n\t\tpreviousUnmountHandler && previousUnmountHandler( oldState );\n\t\t// Call executeHandler with new and old state\n\t\tconst executeResult = executeHandler( state, oldState )\n\t\t// Get previous unmount handler from return or cancel it\n\t\tpreviousUnmountHandler = (\n\t\t\t_typeof(executeResult, \"f\")\n\t\t\t? executeResult as UnmountTrackHandler<GState>\n\t\t\t: null\n\t\t)\n\t}\n\t// After component just rendered\n\tlet firstRender = true\n\tcomponent._renderHandlers.push( () => {\n\t\t// Always execute handler at first render\n\t\tif ( firstRender ) {\n\t\t\tupdateState( null );\n\t\t\tfirstRender = false;\n\t\t} else {\n\t\t\t// Otherwise, detect changes\n\t\t\tconst oldState = state;\n\t\t\tstate = ( detectChanges as DetectChanges<GState> )();\n\t\t\t// Check if any part of state changed\n\t\t\tif ( state.filter( (e, i) => oldState[i] != e ) )\n\t\t\t\tupdateState( oldState )\n\t\t}\n\t})\n}\n","// Import it like any other v-dom lib\nimport { h, render, state, changed, ref, mounted } from \"../src/reflex\";\n\n// Reflex components can be pure functions or factory functions\nfunction ReflexApp ( props ) {\n\t// How basic state works\n\tconst counter = state( 0 )\n\tconst increment = () => counter.set( counter.value + 1 )\n\tconst reset = () => counter.set( 0 )\n\n\t// No need to use ref for locally scoped variables\n\tlet firstUpdate = true\n\t// Detect changes of states or props\n\tchanged(() => [counter.value], newValue => {\n\t\tconsole.log(`Counter just updated to ${newValue}`, firstUpdate)\n\t\tfirstUpdate = false\n\t})\n\n\t// How refs of dom elements works\n\tconst title = ref()\n\tmounted(() => console.log(title.dom.innerHTML) )\n\n\t// Returns a render function\n\t// Classes can be arrays ! Falsy elements of the array will be discarded\n\treturn () => <div class={[ \"ReflexApp\", props.modifier, false ]}>\n\t\t<h1 ref={ title }>Hello from Reflex { props.emoji }</h1>\n\t\t<button onClick={ increment }>Increment</button>&nbsp;\n\t\t<button onClick={ reset }>Reset</button>&nbsp;\n\t\t<span>Counter : { counter.value }</span>\n\t</div>\n}\n\n// Render it like any other v-dom library\nrender( <ReflexApp modifier=\"ReflexApp-darkMode\" emoji=\"👋\" />, document.body )"],"names":["$2f7240e2d23dac03$export$7e76fa19994d71a9","window","queueMicrotask","h","setTimeout","$2f7240e2d23dac03$export$fddd3158ad8f7ea8","entity","firstLetterOfType","$2f7240e2d23dac03$export$6248422ce2978ee","indexOf","$2f7240e2d23dac03$export$1eef345d23861417","vnode","props","children","flat","$2e085b009da21c57$export$30e635e6d2915565","type","key","ref","_ref","$2e085b009da21c57$export$dda1d9f60106f0e9","nodeProps","i","value","startsWith","push","Array","isArray","concat","map","child","$eae8f6c98513451a$export$66fe0842e8a0b300","_propsProxy","$eae8f6c98513451a$var$createPropsProxy","_isDirty","isMounted","name","_mountHandlers","_renderHandlers","_unmountHandlers","_observables","proxy","Proxy","get","target","propName","set","newProps","$eae8f6c98513451a$export$512a9fc9a4079174","node","doMount","component","c","_component","handler","mountedReturn","apply","o","dispose","$eae8f6c98513451a$export$fa7568cd9f443b42","$b55a461f4688c32b$var$_IS_NON_DIMENSIONAL_REGEX","$b55a461f4688c32b$var$_CAPTURE_REGEX","$b55a461f4688c32b$var$_hookedComponent","$b55a461f4688c32b$export$cc5e6a61e45cbc80","$b55a461f4688c32b$var$getEventNameAndKey","dom","useCapture","replace","eventName","toLowerCase","slice","$b55a461f4688c32b$var$updateNodeRef","_setFromVNode","$b55a461f4688c32b$export$f7acac73a490159e","newNode","oldNode","isTextNode","document","createTextNode","createElement","nodeValue","Object","keys","innerHTML","eventKey","removeEventListener","removeAttribute","Map","addEventListener","filter","v","join","trim","k","style","setProperty","test","$b55a461f4688c32b$var$setStyle","setAttribute","$b55a461f4688c32b$export$c33fc81d4c86e067","newParentNode","oldParentNode","newChildren","oldChildren","parentDom","_keys","registerKey","newChildNode","$b55a461f4688c32b$export$a148733e8fa3008f","appendChild","lostIndexes","oldChild","oldParentKeys","collapseCount","_keep","collapsedIndex","insertBefore","oldChildNode","removeChild","$b55a461f4688c32b$var$renderComponentNode","result","_render","renderResult","_id","isFactory","a","b","pure","length","every","hasOwnProperty","Element","$81d9b1de2eabf71b$var$componentsToUpdate","$81d9b1de2eabf71b$var$updateDirtyComponents","$81d9b1de2eabf71b$export$d86d0cc00dc6bc42","$6f1f8f6f71e328d0$export$8210dfe1863c478","_listeners","remove","l","add","once","callAtInit","dispatch","rest","listener","clear","listeners","$67ba320a79f9dae6$var$executeSetter","currentValue","setter","$67ba320a79f9dae6$export$2985e25a327f08f0","initialValue","$67ba320a79f9dae6$var$prepareInitialValue","onChanged","newValue","$67ba320a79f9dae6$export$eaa260439225e231","beforeChanged","bit","async","oldValue","$8aa3021def56a9de$export$ca000e230c0caa3e","observable","$949571a43ff927b1$export$eff4d24c3ff7876e","$814c192c3d6743bf$export$a9c18da36281d08","detectChanges","executeHandler","previousUnmountHandler","state","updateState","oldState","executeResult","firstRender","e","$ab71e95a90becd67$var$ReflexApp","counter","increment","reset","firstUpdate","console","log","title","class","modifier","emoji","onClick","rootNode","parentElement","root","item","body"],"version":3,"file":"example.02f46bf7.js.map"}