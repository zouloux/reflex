{"mappings":"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","sources":["demos/4-store-list-demo/index.tsx","src/store/store.ts","demos/4-store-list-demo/StoreListDemoApp.tsx","src/store/reflexStoreState.ts","demos/demoHelpers.ts","src/reflex/debug.ts"],"sourcesContent":["import { h, render } from \"../../src/reflex\";\nimport { StoreListDemoApp } from \"./StoreListDemoApp\";\nimport { setReflexDebug, trackPerformances } from \"../../src/reflex/debug\";\n\n// -----------------------------------------------------------------------------\n\nsetReflexDebug( true )\n\nlet renderIndex = 0\nexport function init () {\n\tconst p = trackPerformances(\"Root rendering\")\n\trender( <StoreListDemoApp render={ init } renderIndex={ renderIndex ++ } /> , document.body );\n\tp();\n}\n\ninit();\n","import { ISignal, Signal } from \"@zouloux/signal\";\n\n/**\n * TODO :\n * - ASK ONLINE : Refactor arguments types generics\n * \t\tTODO : Clean types ! Reducers do not throw if wrong props are used in state !\n * - YEP : Able to connect it simply to cookey !\n *     - cookeyStore( store:IStore, name:string, propsToStore:{keyof Store}[] )\n * - NOPE : Separate classic and await code ?\n * - Create CancellablePromise ? Should help a lot.\n *\n * Goals :\n * - Base of next router ðŸ¥°\n * - Keep size ultra low\n * - Reflex / React / Preact compatibility.\n * - Find nice name.\n */\n\n\n// ----------------------------------------------------------------------------- STRUCT\n\n// Return types for before and after signals. Before are asynchronous, after are synchronous.\ntype TOnBeforeReturnType = Promise<any>\ntype TOnAfterReturnType = Exclude< any, Promise<any> >\ntype THandlerParameters<GState> = [ nextState:GState, oldState?:GState ]\n\n// Argument for setState, can be a state object or a function which returns a state\ntype TStateSetter <GState extends object, GArguments extends any[]> = GState | ( (state:GState) => GState )\n\n// Describes a reducer function\n// Returning state is optional\ntype TReducer <GState extends object, GArguments extends any[]> = ( state:GState, ...rest:GArguments ) => GState//|void//GState|Promise<GState>|void\n\n// List of reducers, with reducer as key, and reducer function as value\n// export type TReducers <GState extends object, GReducerActions extends string, GArguments extends any[]> = {\nexport type TReducers <GState extends object, GReducers extends object, GArguments extends any[]> = {\n\t[ reducer in keyof GReducers ] ?: TReducer <GState, GArguments>\n}\n\n// TODO : DOC\ntype TActions = { [key:string]:(...rest) => any }\n\nexport interface IStore <GState extends object, GReducers extends object = object, GArguments extends string[] = any[], GActions extends TActions = TActions>\n{\n\t/**\n\t * Retrieve current store state object\n\t */\n\tgetState\t: () => GState\n\n\t/**\n\t * Update store state and call all listeners.\n\t * Can be a function which take current state as argument and returns new state.\n\t */\n\tsetState\t: ( newState: TStateSetter<GState, GArguments> ) => void\n\n\t/**\n\t * Call a reducer.\n\t * ex : dispatch('reducerKey', 'parameter after state')\n\t * With reducers = {\n\t *     reducerKey: (s, p) => { p == 'parameter after state' }\n\t * }\n\t * @param reducer Reducer name, key of reducers.\n\t * @param rest Parameters given to reducer functions, after state argument.\n\t */\n\tdispatch\t: ( reducer:(keyof GReducers), ...rest:GArguments ) => Promise<void>\n\t// dispatch\t: ( ...rest:GArguments ) => void\n\n\t/**\n\t * Listen when state is about to be updated with setState or dispatch.\n\t * Attach only asynchronous listeners.\n\t * Listener can prevent state changes :\n\t * Any listener rejection will cause state to be not updated\n\t * Actual state change and all after listeners will be called after all before listeners.\n\t * @param listener Called when state will be updated\n\t * @returns Returns a function to remove this handler.\n\t */\n\tonBefore\t:ISignal<[GState, GState], Promise<any>>\n\n\t/**\n\t * Listen when state is updated with setState or dispatch.\n\t * Attach only synchronous listeners.\n\t * Called after all before listeners, if none of them rejected state change.\n\t * @param listener Called when state has been changed.\n\t * @returns Returns a function to remove this handler.\n\t */\n\tonAfter\t\t:ISignal<[GState, GState], Exclude<any, Promise<any>>>\n\n\t/**\n\t * When any on before signal handler prevented state change.\n\t */\n\tonCanceled\t:ISignal<[any]>\n\n\t// FIXME : Kill and override current updating state ?\n\t// onKilled\t:ISignal\n\t// kill : () => void\n\n\t/**\n\t * Lock or unlock state updates dispatches.\n\t * If lock(true) is called, any state updated through setState or dispatch\n\t * will not notify attached before or after event listeners.\n\t * When calling lock(false), all listener will be notified if state has changed.\n\t * It allows to optimize listeners notifications with this pattern :\n\t * s.lock( true )\n\t * s.dispatch(...)\n\t * s.dispatch(...)\n\t * s.setState(...)\n\t * s.lock( false ) // will notify and update components state only once here\n\t */\n\tlock\t\t: ( locked:boolean ) => Promise<void>\n\n\t/**\n\t * If store is currently manually locked\n\t */\n\treadonly locked : boolean\n\n\t/**\n\t * If store is currently dispatching an reducer asynchronously\n\t */\n\t// readonly isDispatching : boolean\n\n\t/**\n\t * If store is currently updating state asynchronously\n\t */\n\treadonly isUpdating : boolean\n\n\t// TODO DOC\n\tactions:GActions\n}\n\n\n// ----------------------------------------------------------------------------- CREATE STORE\n\nexport function createStore\n\t<\n\t\tGState extends object,\n\t\tGReducers extends TReducers<GState, GReducers, GArguments>,\n\t\tGArguments extends any[] = any[],\n\t\tGActions extends TActions = TActions\n\t\t// TODO : Typed GArguments if possible with Typescript\n\t\t// GArguments extends any[] = Partial<[\n\t\t// \tParameters<GReducers[keyof GReducers]>[1],\n\t\t// \tParameters<GReducers[keyof GReducers]>[2],\n\t\t// \tParameters<GReducers[keyof GReducers]>[3],\n\t\t// \tParameters<GReducers[keyof GReducers]>[4],\n\t\t// \tParameters<GReducers[keyof GReducers]>[5],\n\t\t// \tParameters<GReducers[keyof GReducers]>[6],\n\t\t// \tParameters<GReducers[keyof GReducers]>[7],\n\t\t// \tParameters<GReducers[keyof GReducers]>[8],\n\t\t// \tParameters<GReducers[keyof GReducers]>[9],\n\t\t// ]>,\n\t\t// GReducerActions extends string = keyof GReducers,\n\t\t// GReducers extends TReducers<GState, GReducers, GArguments>,\n\t\t// GArguments extends any[] = Partial<[\n\t\t// \t// FIXME : Refactor this, is it possible in current TS State ?\n\t\t// ]>\n\t\t// GArguments extends any[] = [\n\t\t// \tkeyof GReducers,\n\t\t// \t// ...Parameters<GReducers[keyof GReducers]>\n\t\t// ]\n\t>\n\t( state:GState = null, reducers:GReducers = null, actions ?: GActions )\n\t: IStore<GState, GReducers, GArguments, GActions>\n{\n\t// Init signals\n\tconst onBefore = Signal<THandlerParameters<GState>, TOnBeforeReturnType>()\n\tconst onAfter = Signal<THandlerParameters<GState>, TOnAfterReturnType>()\n\tconst onCanceled = Signal<[any]>()\n\t// Init properties\n\tlet isLocked = false\n\t// let _isDispatching = false\n\tlet isUpdating = false\n\tlet lockUpdated = false\n\t// Update state and call listeners\n\t// Will be synchronous if there are no asynchronous before listeners\n\tconst update = async ( newState = state ) => {\n\t\t// Dispatch are locked, just save new state\n\t\t// without dispatching before or after listeners\n\t\tif ( isLocked ) {\n\t\t\t// Remember that state has been updated while locked\n\t\t\t// To dispatch new state when unlocking\n\t\t\tlockUpdated = true\n\t\t\t// Save new state\n\t\t\tstate = newState\n\t\t\treturn\n\t\t}\n\t\t// Prevent dispatches\n\t\tisUpdating = true\n\t\t// Dispatch all asynchronous before listeners\n\t\tlet oldState = state\n\t\t// Only if we have some listeners, otherwise keep it synchronous\n\t\tif ( onBefore.listeners.length > 0 ) {\n\t\t\t// Start all promises in parallel\n\t\t\ttry {\n\t\t\t\tawait Promise.all( onBefore.listeners.map(\n\t\t\t\t\tasync l => await l( newState, oldState )\n\t\t\t\t))\n\t\t\t\t// FIXME : Add sequential option ?\n\t\t\t\t// for ( const listener of _beforeListeners )\n\t\t\t\t// \tawait listener( newState, oldState )\n\t\t\t}\n\t\t\t// Stop update if any of those middlewares trows rejection\n\t\t\tcatch ( e ) {\n\t\t\t\tonCanceled.dispatch( e )\n\t\t\t\tisUpdating = false\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t// All listeners validated state change, save new state\n\t\tstate = newState\n\t\t// Unlock right before after listeners so they can dispatch if needed\n\t\tisUpdating = false\n\t\t// Notify all after listeners that state changed\n\t\tonAfter.dispatch( newState, oldState )\n\t}\n\t// Expose public API\n\treturn {\n\t\t// Get and set state\n\t\tgetState : () => state,\n\t\tsetState : ( newState:TStateSetter<GState, GArguments> ) => update(\n\t\t\t// Call state updater if it's a function\n\t\t\t( typeof newState === 'function' ? (newState as Function)( state ) : newState )\n\t\t),\n\t\t// Dispatch reducer\n\t\tdispatch : ( reducerName:(keyof GReducers), ...rest:GArguments ) => new Promise<void>( async (resolve, reject) => {\n\t\t\t// FIXME -> Dispatch should be able to override updating state\n\t\t\t// FIXME -> And kill current onBefore listeners\n\t\t\t// Already updating state asynchronously\n\t\t\tif ( isUpdating )\n\t\t\t\treturn reject('updating')\n\t\t\t// Call reducer synchronously and update reduced data\n\t\t\tawait update( reducers[ reducerName ]( state, ...rest) as GState )\n\t\t\t// Everything has been dispatched successfully\n\t\t\tresolve()\n\t\t}),\n\t\t// Expose signals\n\t\tonBefore,\n\t\tonAfter,\n\t\tonCanceled,\n\t\t// Lock or unlock updates\n\t\tasync lock ( locked:boolean ) {\n\t\t\tisLocked = locked\n\t\t\t// If unlocking and state has changed while locked\n\t\t\tif ( !isLocked && lockUpdated ) {\n\t\t\t\t// Dispatch new state\n\t\t\t\tlockUpdated = false\n\t\t\t\tawait update( state )\n\t\t\t}\n\t\t},\n\t\t// Get locked states\n\t\tget locked () { return isLocked },\n\t\t// get isDispatching () { return _isDispatching },\n\t\tget isUpdating () { return isUpdating },\n\t\t// Expose actions\n\t\tactions\n\t}\n}","import { h, ref } from \"../../src/reflex\";\nimport { createStore } from \"../../src/store/store\";\nimport { storeState } from \"../../src/store/reflexStoreState\";\nimport { colorList, createUID, foodList, pickRandom, rand } from \"../demoHelpers\";\n\n// ----------------------------------------------------------------------------- STORE\n\ninterface IListItem {\n\tname\t:string\n\tid\t\t:string\n}\n\nconst getInitialListState = ():IListItem[] => []\n\nconst listStore = createStore( getInitialListState(), {\n\tclearList () {\n\t\treturn getInitialListState()\n\t},\n\taddItem ( state, position:\"top\"|\"bottom\", item:IListItem ) {\n\t\treturn position === \"bottom\" ? [ ...state, item ] : [ item, ...state ]\n\t},\n\tremoveItem ( state, item:IListItem ) {\n\t\treturn state.filter( currentItem => currentItem != item )\n\t},\n\tmoveItem ( state, item:IListItem, offset:number ) {\n\t\tconst index = state.indexOf( item ) + offset\n\t\tif ( index < 0 || index >= state.length ) return;\n\t\tstate = this.removeItem( state, item )\n\t\tstate.splice( index, 0, item )\n\t\treturn state\n\t},\n\taddRandomItems ( state, total:number = 0 ) {\n\t\ttotal ||= rand( 5 + state.length ) + 1\n\t\tfor ( let i = 0; i < total; ++i ) {\n\t\t\tstate = this.addItem(state, \"bottom\", {\n\t\t\t\tid: createUID(),\n\t\t\t\tname: pickRandom(colorList) + \" \" + pickRandom(foodList)\n\t\t\t})\n\t\t}\n\t\treturn state\n\t},\n\tremoveRandomItems ( state ) {\n\t\tconst total = rand( state.length ) + 1\n\t\tfor ( let i = 0; i < total; ++i ) {\n\t\t\tconst item = pickRandom( state )\n\t\t\tstate = this.removeItem( state, item )\n\t\t}\n\t\treturn state\n\t}\n})\n\n// ----------------------------------------------------------------------------- LIST ITEM\n\nconst listItemStyle = {\n\tborder\t: `1px solid black`\n}\n\ninterface IListItemProps {\n\titem\t: IListItem\n\tkey\t\t?\n}\n\nfunction ListItem ( props:IListItemProps ) {\n\t// console.log(\"ListItem\")\n\tconst { item } = props;\n\treturn <tr class=\"ListItem\" data-id={ item.id } style={ listItemStyle }>\n\t\t<td>{ item.name }</td>\n\t\t<td><button onClick={ e => listStore.dispatch(\"moveItem\", item, -1 ) }>â¬†</button></td>\n\t\t<td><button onClick={ e => listStore.dispatch(\"moveItem\", item, +1 ) }>â¬‡</button></td>\n\t\t<td><button onClick={ e => listStore.dispatch(\"removeItem\", item ) }>Remove</button></td>\n\t</tr>\n}\n\n// ----------------------------------------------------------------------------- LIST APP\n\nexport function StoreListDemoApp ( props ) {\n\n\tconst list = storeState( listStore )\n\tconst nameInput = ref<HTMLInputElement>()\n\n\tfunction controlSubmitted ( event:Event ) {\n\t\tevent.preventDefault()\n\t\tif ( !nameInput.dom.value ) return;\n\t\tlistStore.dispatch(\"addItem\", \"top\", {\n\t\t\tname: nameInput.dom.value,\n\t\t\tid: createUID()\n\t\t})\n\t\tnameInput.dom.value = \"\"\n\t}\n\n\tfunction Controls () {\n\t\treturn <div className=\"StatefulDemoApp_controls\">\n\t\t\t<table>\n\t\t\t\t<button onClick={ e => listStore.dispatch(\"addRandomItems\") }>Add random items to bottom</button>\n\t\t\t\t<button onClick={ e => listStore.dispatch(\"addRandomItems\", 1_000 ) }>Add 1.000 items to bottom</button>\n\t\t\t\t<button onClick={ e => listStore.dispatch(\"addRandomItems\", 10_000 ) }>Add 10.000 items to bottom</button>\n\t\t\t\t<button onClick={ e => listStore.dispatch(\"removeRandomItems\") }>Remove random items</button>\n\t\t\t\t<button onClick={ e => listStore.dispatch(\"clearList\") }>Clear list</button>\n\t\t\t</table>\n\t\t\t<form onSubmit={ controlSubmitted }>\n\t\t\t\t<table>\n\t\t\t\t\t<input\n\t\t\t\t\t\tid=\"StatefulDemoApp_nameInput\" ref={ nameInput }\n\t\t\t\t\t\ttype=\"text\" name=\"name\" placeholder=\"Name ...\"\n\t\t\t\t\t/>\n\t\t\t\t\t<button type=\"submit\">Add to top</button>\n\t\t\t\t</table>\n\t\t\t</form>\n\t\t</div>\n\t}\n\n\treturn () => <div class=\"StatefulDemoApp\">\n\t\t<span>Root render index : { props.renderIndex }</span>\n\t\t<Controls />\n\t\t<h3>{ list.value.length } element{ list.value.length > 1 ? 's' : '' }</h3>\n\t\t<table>\n\t\t\t{ list.value.map( item =>\n\t\t\t\t<ListItem item={ item } key={ item.id } />\n\t\t\t)}\n\t\t</table>\n\t</div>\n}\n","import { IStore } from \"./store\";\nimport { state } from \"../reflex\";\nimport { IStateObservable } from \"@zouloux/signal\";\n\n\nexport function storeState <GType extends object> ( store:IStore<GType> ) : IStateObservable<GType>\n{\n\tconst bit = state<GType>( store.getState() )\n\tstore.onAfter.add( () => bit.set( store.getState() ) )\n\t// TODO : When component is removed, remove onAfter listener\n\treturn bit;\n}\n","\nexport const toHex = (n:number) => (~~n).toString(16)\nexport const createUID = () => `${toHex(Date.now())}-${toHex(Math.random() * 999999999)}`;\nexport const pickRandom = <G extends any>(array:G[]):G => array[ ~~(Math.random() * array.length) ]\nexport const rand = (max:number) => ~~(Math.random() * max)\nexport const randBoolean = (threshold = .5) => (Math.random() > threshold)\n\nexport const foodList = [\"Cheese\", \"Carrots\", \"Pastas\", \"Pizza\", \"Burgers\", \"Ham\", \"Salad\", \"Mustard\"]\nexport const colorList = [\"Red\", \"Blue\", \"Yellow\", \"Purple\", \"Orange\", \"Black\", \"White\", \"Green\"]\nexport const firstnameList = [\"Alfred\", \"Jessica\", \"Gwen\", \"Jeanne\"]\nexport const lastnameList = [\"Dupont\", \"Smith\", \"Stevensen\", \"Odea\"]\n","\n// ----------------------------------------------------------------------------- ENABLE / DISABLE\n\nlet _enableReflexDebug = false;\n\nexport function getReflexDebug () { return _enableReflexDebug }\nexport function setReflexDebug (value:boolean) {\n\t_enableReflexDebug = value\n}\n\n// ----------------------------------------------------------------------------- TRACK PERFORMANCES\n\nexport function trackPerformances ( subject:string ) {\n\tif ( !_enableReflexDebug || process.env.NODE_ENV === \"production\" )\n\t\treturn () => {};\n\tconst start = performance.now()\n\treturn () => {\n\t\tconst delta = ~~( performance.now() - start )\n\t\tconsole.info( subject, delta < 1000 ? `${delta}ms` : `${delta/1000}s`)\n\t}\n}"],"names":["$leUMy","parcelRequire","$8HdjB","$96a40833a1e192e7$export$ca97131192bad836","store","bit","state","getState","onAfter","add","set","$00c98e03044c15dd$export$7ea66e3774a60b67","n","toString","$00c98e03044c15dd$export$c55f232b018cefe7","Date","now","Math","random","$00c98e03044c15dd$export$2e015b6955893291","array","length","$00c98e03044c15dd$export$bb0a9c36cf454ea0","max","$00c98e03044c15dd$export$4815de0a6e6c5145","$00c98e03044c15dd$export$9afc515fe5566574","$594053b76a28eecd$var$listStore","reducers","actions","onBefore","Signal","onCanceled","isLocked","isUpdating","lockUpdated","update","async","newState","oldState","listeners","Promise","all","map","l","e","dispatch","setState","reducerName","rest","resolve","reject","locked","clearList","addItem","position","item","removeItem","filter","currentItem","moveItem","offset","index","indexOf","this","splice","addRandomItems","total","i","id","name","removeRandomItems","$594053b76a28eecd$var$listItemStyle","border","$594053b76a28eecd$var$ListItem","props","h","class","style","onClick","$594053b76a28eecd$export$c46037201fc34f4e","list","nameInput","ref","controlSubmitted","event","preventDefault","dom","value","Controls","className","onSubmit","type","placeholder","renderIndex","key","$228131962d4ca37f$var$_enableReflexDebug","$df30f2b2a23f0c82$var$renderIndex","$df30f2b2a23f0c82$export$2cd8252107eb640b","p","render","document","body"],"version":3,"file":"index.d83bb7e3.js.map"}