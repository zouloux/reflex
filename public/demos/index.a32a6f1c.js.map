{"mappings":"q5BAiGAA,EAAA,S,8GCjGA,IAAAC,EAAAD,EAAA,S,0BASO,SAASE,EAAgBC,GAC/B,MAAMC,GAAY,EAAAH,EAAAI,sBACZC,GAAa,EAAAC,EAAAC,uBAAuBL,GAAc,KAAM,EAAAM,EAAAC,qBAAqBN,KAEnF,OADAA,EAAUO,aAAaC,KAAMN,GACtBA,M,qMCbR,IAAAO,EAAAb,EAAA,S,0BAoBO,MAAMc,EAAgC,MAMvCC,EAAyB,oEAGzBC,EAAc,WAKpB,IAAIC,EAAqC,KAClC,SAASC,IAIf,OAAOD,EAKR,SAASE,EAAqBC,EAAaC,GAE1C,MAAMC,EAAaF,KAAWA,EAAOA,EAAKG,QAAQP,EAAgB,KAE5DQ,GAAcJ,EAAKK,gBAAiBJ,EAAMD,EAAKK,cAAgBL,GAAOM,MAAM,GAGlF,MAAO,C,UAAEF,E,SADQA,GAAaF,EAAa,IAAM,I,WACnBA,GAgB/B,SAASK,EAAgBC,GAClBA,EAAKC,OAEN,SAAUD,EAAKC,KAGjBD,EAAKC,KAAwBC,aAAc,EAAGF,GAG9CA,EAAKC,KAAuBC,aAAcF,IAiBvC,SAASG,EAAcC,EAAeC,GAE5C,MAAMC,EAAaF,EAAQG,MAAQtB,EAAAuB,qBAE7Bf,EACLY,EAAUA,EAAQZ,IACjBa,EACEG,SAASC,eAAgBN,EAAuBO,MAAMC,OACtDH,SAASI,cAAeT,EAAQG,MAIpC,GAAKD,GAAcD,EAAU,CAC5B,MAAMO,MAAEA,GAAUR,EAAuBO,MAEpCC,GAASnB,EAAcqB,YAC3BrB,EAAgBqB,UAAYF,GAG9B,OAAKN,IAELD,GAAWU,OAAOC,KAAMX,EAAQM,OAAQM,KAAKzB,IAE5C,GAAa,YAARA,MACAA,KAAQY,EAAQO,QAASP,EAAQO,MAAOnB,KAAWa,EAAQM,MAAOnB,IAGvE,GAAa,aAARA,EACJC,EAAmByB,UAAY,QAG3B,GAAK1B,EAAK2B,WAAW,MAAQ,CACjC,MAAMvB,UAAEA,EAASwB,SAAEA,EAAQ1B,WAAEA,GAAeH,EAAoBC,EAAMC,GACtEA,EAAI4B,oBAAqBzB,EAAWH,EAA+B,IAAI2B,GAAY1B,QAInFD,EAAmB6B,gBAAiB9B,MAItCuB,OAAOC,KAAMZ,EAAQO,OAAQM,KAAKzB,IACjC,GAAa,YAARA,EAAqB,OAC1B,IAAIoB,EAAQR,EAAQO,MAAOnB,GAE3B,IAAKa,KAAWb,KAAQa,EAAQM,QAASN,EAAQM,MAAOnB,KAAWoB,EAGnE,GAAa,aAARpB,EACJC,EAAmByB,UAAYN,OAG3B,GAAKpB,EAAK2B,WAAW,MAAQ,CACjC,MAAMvB,UAAEA,EAASwB,SAAEA,EAAQ1B,WAAEA,GAAeH,EAAoBC,EAAMC,GAEtEA,EAA+B,MAAO,IAAI8B,IAE1C9B,EAA+B,IAAI2B,GAAaR,EAEhDnB,EAAI+B,iBAAkB5B,EAAWgB,EAAOlB,OAGpC,CAKJ,GAHa,aAARF,IACJA,EAAO,SAEK,SAARA,GAAmBiC,MAAMC,QAASd,GACtCA,EAAQA,EAAMe,QAAQC,IAAW,IAANA,KAAgBA,IAAIC,KAAK,KAAKC,WAErD,IAAa,SAARtC,GAAwC,aAAboB,GAAO,GAE3C,OAAOG,OAAOC,KAAMJ,GAAQK,KAC3Bc,GA/GJ,SAAmBC,EAA2BC,EAAYrB,GAC3C,MAAXqB,EAAI,GACPD,EAAME,YAAYD,EAAKrB,GACN,MAATA,EACRoB,EAAMC,GAAO,GAEgB,aAAbrB,GAAO,IAAazB,EAA0BgD,KAAKF,GACnED,EAAMC,GAAOrB,EAEboB,EAAMC,GAAOrB,EAAQ,KAsGbwB,CAAU3C,EAAqBuC,MAAOD,EAAGnB,EAAMmB,MAGjD,GAAc,GAATnB,EACT,OAGDnB,EAAmB4C,aAAc7C,EAAMoB,QA7DhBnB,EA0EnB,SAAS6C,EAAeC,EAAqBC,GAGnD,MAAMC,EAAcF,EAAc5B,MAAM+B,UAAUC,OAC5CC,EAAcJ,GAAe7B,MAAM+B,UAAUC,OAEnD,IAAMF,EAAc,OACpB,MAAMI,EAAYN,EAAc9C,IAIhC8C,EAAcO,MAAQ,IAAIvB,IAC1B,MAAMwB,EAAcC,IACdA,GAAGf,MAAMM,EAAcO,MAAOE,EAAEf,KAAQe,IAI9C,IAAMJ,EAQL,YAPAH,EAAYxB,KAAKgC,IACXA,IACLC,EAAUD,GACVJ,EAAUM,YAAaF,EAAaxD,KAEpCsD,EAAaE,OAOfR,EAAYxB,IAAK8B,GAGjB,MAAMK,EAAcR,EAAY3B,KAC/BoC,MAAeA,GAAUpB,KAAQM,EAAcO,MAAMO,EAASpB,QAGzDqB,EAAgBd,EAAcM,MACpC,IAAIS,EAAgB,EAEpBd,EAAYxB,KAAK,CAACgC,EAAcO,KAS/B,GALKJ,EAAYI,IAChBD,IAIKN,EAIN,GACCA,EAAahB,KACVqB,EAAeL,EAAahB,MAC5BqB,EAAeL,EAAahB,KAAM1B,MAAQ0C,EAAa1C,KACzD,CACD,MAAMF,EAAUiD,EAAeL,EAAahB,KAC5CiB,EAAUD,EAAc5C,GACxBA,EAAQoD,OAAQ,EAEhB,MAAMC,EAAiBF,EAAID,EAGtBX,EAAYe,QAAStD,IAAaqD,GACtCb,EAAUe,aAAcX,EAAaxD,IAAKoD,EAAUH,SAAUc,SAI3D,GAAKP,EAAahB,MAAQqB,EAAeL,EAAahB,KAC1DiB,EAAUD,GACVJ,EAAUe,aAAcX,EAAaxD,IAAKoD,EAAUH,SAAUc,IAC9DD,SAKI,GAAKC,KAAKZ,GAAeA,EAAaY,IAAOZ,EAAaY,GAAIjD,MAAQ0C,EAAa1C,KAAO,CAC9F,MAAMF,EAAUuC,EAAaY,GAC7BN,EAAUD,EAAc5C,GACxBA,EAAQoD,OAAQ,OAKhBP,EAAUD,GACVJ,EAAUe,aAAcX,EAAaxD,IAAKoD,EAAUH,SAAUc,IAC9DD,OAKFX,EAAY3B,KAAK4C,IAChB,GAAKA,IAAiBA,EAAaJ,MAAQ,EAE1C,EAAAK,EAAAC,6BAA6BF,GAAc,GAE3C,MAAMpE,IAAEA,GAAQoE,EAChBA,EAAapE,IAAM,KACnBM,EAAe8D,GACfhB,EAAUmB,YAAavE,OAO1B,SAASwE,EAAkDjE,EAAqCxB,GAE/FA,EAAU0F,MAAQlE,EAClBA,EAAKmE,WAAa3F,EAElBa,EAAmBb,EAInB,MAAM4F,GAAU5F,EAAU6F,SAAWrE,EAAKO,MACxC+D,MAAO9F,EAAW,CAAEA,EAAU+F,YAAY3D,QAG5C,OADAvB,EAAmB,KACZ+E,EAGD,SAASlB,EAAW9C,EAAeC,GAIpCA,GAAWA,IAAYD,IAC3BA,GAAU,EAAAoE,EAAAC,YAAYpE,IAEvB,IAEIqE,EAkBAjF,EApBAjB,EAA8B6B,GAAS8D,WAG3C,IAAM3F,IAAa,EAAAS,EAAA0F,aAAYvE,EAAQG,MAAQ,CAE9C/B,GAAY,EAAAsF,EAAAc,yBAAyBxE,GAErC,MAAMgE,EAASH,EAAqB7D,EAA2C5B,IAE1E,EAAAS,EAAA0F,aAAYP,IAChB5F,EAAU6F,QAAUD,EACpB5F,EAAUqG,WAAY,GAGS,aAAdT,GAAQ,IAAa,SAAUA,IAChD5F,EAAU6F,QAAUjE,EAAQG,KAC5B/B,EAAUqG,WAAY,EACtBH,EAAeN,GA3PU,IAAEU,EAAUC,EAgQjCvG,IAgBHkG,GAEErE,IAAY7B,EAAUqG,YAEC,IAAvBzE,EAAQO,MAAMqE,MAGoB,IAAlC5E,EAAQO,MAAM+B,SAASuC,SAvRCH,EAyRJ1E,EAAQO,MAzRMoE,EAyRC1E,EAAQM,MAvRhDI,OAAOC,KAAK8D,GAAGG,SAAWlE,OAAOC,KAAK+D,GAAGE,QAGtClE,OAAOC,KAAK8D,GAAGI,OAAOjD,GAAe,aAARA,GAAuB8C,EAAEI,eAAelD,IAAQ6C,EAAE7C,KAAS8C,EAAE9C,OA2R3F7B,EAAQO,MAAM+B,SAAWrC,EAAQM,MAAM+B,SACvCtC,EAAQX,IAAMA,EAAMY,EAAQZ,KAGlBiF,IACVlG,EAAU+F,YAAYa,IAAKhF,EAAQO,OACnC+D,EAAeT,EAA4B7D,EAA2C5B,IAGlFkG,IAEJtE,EAAQO,MAAM+B,UAAW,EAAAzD,EAAAoG,kBAAkBX,GAE3CtE,EAAQX,IAAMA,EAAMU,EAAauE,EAAcrE,GAE/CD,EAAQH,KAAOyE,EAAazE,MAG7BG,EAAQ+D,WAAa3F,EACrBA,EAAU0F,MAAQ9D,EAElB5B,EAAU8G,UAAW,GApDrBlF,EAAQX,IAAMA,EAAMU,EAAaC,EAASC,GAuD3CN,EAAeK,GAEVX,aAAe8F,SACnBjD,EAAclC,EAASC,GAEnB7B,IAAcA,EAAUgH,YAC5B,EAAA1B,EAAAC,6BAA6B3D,GAAS,GAEvC5B,GAAWiH,gBAAgBxE,KAAKyE,GAAKA,U,0QCnY/B,MAAMC,EAAuB,KACvBC,EAAuB,KASvBC,EAAeC,OAAOC,gBAAoB,CAAAL,GAAKI,OAAOE,WAAYN,EAAG,IAMrEO,EAAmBC,GAAoBzE,MAAMC,QAASwE,GAASA,EAAO,CAAEA,GAGxEC,EAAcC,GAAwB,aAAVA,GAAI,GAEtC,SAASC,EAAmBnC,GAElC,OAAOA,EAAMvD,MAAM+B,SAAYwB,EAAMvD,OAAO+B,UAAUC,QAAU,O,gICvCjE,IAAA1D,EAAAb,EAAA,SAIO,SAASkI,EAAc/F,EAAMI,EAAOsB,EAAMsE,GAChD,MAAO,CAAEhG,KAAMA,EAAMI,MAAOA,EAAOsB,IAAKA,EAAKhC,KAAMsG,GAG7C,SAASC,EAAatC,GAC5B,MAAO,IACHA,EAEHvD,MAAO,IAAKuD,EAAMvD,QAKb,SAAS8F,EAAIlG,EAAMI,KAAU+B,GAGnC,IACIT,EAAKsE,EADLG,EAAgB,GAEpB,IAAM,IAAIlD,KAAK7C,EAAQ,CACtB,MAAMC,EAAQD,EAAO6C,GAEX,OAALA,EACJvB,EAAMrB,EACQ,OAAL4C,EACT+C,EAAM3F,EAEI4C,EAAErC,WAAW,QACvBuF,EAAUlD,GAAK5C,GAUjB,OAPA8F,EAAUhE,SAAWA,EAASzB,KAAK0F,IAEW,GAA3C,CAAC,IAAK,KAAKhD,gBAAiBgD,GAAO,IACnCL,EAAarH,EAAAuB,qBAAsB,CAAEI,MAAO,GAAK+F,IAEjDA,IAEIL,EAAa/F,EAAMmG,EAAWzE,EAAKsE,O,oICzC3C,IAAAtH,EAAAb,EAAA,SA2BO,SAASwI,EAA0B1C,GACzC,MAAO,C,MACNA,EACAK,YAAasC,EAAkB3C,EAAMvD,OACrC2E,UAAU,EACVE,WAAW,EACXhG,KAAM0E,EAAM3D,KAAKf,KACjBsH,eAAgB,GAChBrB,gBAAiB,GACjBsB,iBAAkB,GAClBhI,aAAc,IAkBhB,SAAS8H,EAA4BlG,GACpC,MAAMqG,EAAQ,IAAIC,MAAM,GAAI,CAE3BC,IAAG,CAAGC,EAAWC,IACPA,KAAYzG,EAAQA,EAAOyG,QAAa,EAGlDhC,IAAG,KACiD,IAIrD,MAAO,CAEFxE,YAAW,OAAOoG,GAEtB5B,IAAMiC,GAAoB1G,EAAQ0G,IA+B7B,SAASC,EAA8BtH,EAAYuH,GAzBnD,IAA0B/I,EA0B3BwB,EAAKO,MAAQtB,EAAAuB,wBAClB,EAAAvB,EAAAoG,kBAAkBrF,GAAOiB,KAAK+B,GAAKA,GAAKsE,EAA4BtE,EAAGuE,KAClEvH,EAAKmE,aACToD,IA7B+B/I,EA6BLwB,EAAKmE,YA3BtB2C,eAAe7F,KAAKuG,IAC7B,MAAMC,EAAgBD,EAAQlD,MAAO9F,EAAW,KAC3C,EAAAS,EAAA0F,aAAY8C,IAChBjJ,EAAUuI,iBAAiB/H,KAAMyI,MAGnCjJ,EAAUsI,eAAiB,GAC3BtI,EAAUgH,WAAY,GAGhB,SAA4BhH,GAClCA,EAAUuI,iBAAiB9F,KAAKyE,GAAKA,EAAEpB,MAAO9F,EAAW,MACzDA,EAAUO,aAAakC,KAAKyG,GAAKA,EAAEC,mBAI5BnJ,EAAUsI,sBACVtI,EAAUiH,uBACVjH,EAAUuI,wBACVvI,EAAUO,aACjBP,EAAUgH,WAAY,EAOyBoC,CAAkB5H,EAAKmE,kB,2GC1GvE,IAAAlF,EAAAb,EAAA,S,0BAOO,SAASyJ,EAASC,EAAwBC,GAGhD,MAAMC,GAAO,EAAAxD,EAAAyD,aAAahJ,EAAAiJ,qBAAsB,CAAExF,UAAU,EAAAzD,EAAAkJ,aAAaL,KACzEE,EAAKvI,IAAMsI,GACX,EAAA1J,EAAA+J,cAAcJ,EAAMD,EAAe1J,EAAAgK,gCACnCN,EAAe1J,EAAAgK,+BAAkCL,EAKlD,IAAIM,EAAyC,GAC7C,SAASC,IAKRD,EAAmBrH,KAAKzC,KACvB,EAAAH,EAAAmK,UAAUhK,EAAU0F,MAAO1F,EAAU0F,UAEtCoE,EAAqB,GAIf,SAASG,EAAsBjK,GAEF,IAA9B8J,EAAmBrD,SACvB,EAAAhG,EAAAyJ,YAAYH,GAER/J,EAAU8G,WACf9G,EAAU8G,UAAW,EAErBgD,EAAmBtJ,KAAMR,Q,uICvC1B,IAAAmK,EAAAvK,EAAA,S,aAcA,MAIMwK,EAAgB,CAAUC,EAAoBC,KACnD,EAAA7J,EAAA0F,aAAYmE,GAAUA,EAAgCD,GAAiBC,EAsBjE,SAASC,EAAoBxK,GAEnC,IAAIqC,EA7BuB,CAAUrC,IACrC,EAAAU,EAAA0F,aAAYpG,GAAgBA,IAAoCA,EA4B9CyK,CAAqBzK,GAGvC,MAAM0K,GAAY,EAAAN,EAAAO,WACZC,SAAEA,GAAaF,EAGrB,cAFOA,EAAUE,SAEV,C,UACNF,E,SACAE,EACAjC,IAAG,IAAatG,EAChBwE,IAAMgE,GAA4BxI,EAAQgI,EAAchI,EAAOwI,IAC/DzB,UACCsB,EAAUI,QACVzI,EAAQ,OA0CJ,SAAS0I,EACf/K,EACAgL,GAMA,MAAMC,EAAMT,EAAkBxK,GAC9B,MAAO,CAEN0K,UAAWO,EAAIP,UACftB,QAAS6B,EAAI7B,QACT/G,YAAW,OAAO4I,EAAItC,OAC1BuC,UAAYL,GACX,MAAMM,EAAWF,EAAItC,MAGrB,GAFAkC,EAAWR,EAAec,EAAUN,GACpCI,EAAIpE,IAAKgE,GACJG,EAAgB,CAGpB,IAAoB,UADKA,EAAeH,EAAUM,GAIjD,YAFAF,EAAIpE,IAAKsE,GAMXF,EAAIL,SAAUC,EAAUM,KAYpB,SAASC,EACfpL,EACAgL,GAIA,MAAMC,EAAMT,EAAkBxK,GAC9B,IAAIqL,GAAa,EACbC,GAAqB,EACzB,MAAO,CAENZ,UAAWO,EAAIP,UACftB,QAAS6B,EAAI7B,QACT/G,YAAW,OAAO4I,EAAItC,OACtB0C,iBAAgB,OAAOA,GACvBC,yBAAwB,OAAOA,GACnCJ,UAAYL,GAEX,MAAMM,EAAWF,EAAItC,MAIrB,GAHAkC,EAAWR,EAAec,EAAUN,GACpCI,EAAIpE,IAAKgE,GAEJG,EAAgB,CACfK,IACJC,GAAqB,GACtBD,GAAa,EAEb,IAAoB,UADKL,EAAeH,EAAUM,GAKjD,OAHAF,EAAIpE,IAAKsE,GACTE,GAAa,OACbC,GAAqB,GAItB,GADAD,GAAa,EACRC,EAEJ,YADAA,GAAqB,GAKvBL,EAAIL,SAAUC,EAAUM,S,gFCnL3BtL,EAAA,S,2DCIO,SAAS0L,IAEZ,IAAIC,EAAa,GAEjB,MAAMC,EAAUxC,GAAYuC,EAAaA,EAAWpI,QAAOsI,GAAKA,EAAE,KAAOzC,IAEzE,SAAS0C,EAAI1C,EAAS2C,EAAMC,GAAa,GAQrC,OANAL,EAAW/K,KAAK,CAACwI,EAAS2C,IAG1BC,GAAc5C,EAAQlD,MAAM,KAAM7C,MAAMC,QAAQ0I,GAAcA,EAAa,MAGpE,IAAMJ,EAAOxC,GAGxB,MAAO,CAEH0C,IAAG,CAAC1C,EAAS4C,GAAa,IACfF,EAAI1C,GAAS,EAAO4C,GAG/BD,KAAK3C,GACM0C,EAAI1C,GAAS,G,OAExBwC,EACAb,SAAU,IAAIkB,IAASN,EAAW9I,KAAIqJ,IAElCA,EAAS,IAAMN,EAAOM,EAAS,IAExBA,EAAS,MAAMD,MAE1BhB,QAAUU,EAAa,IACnBQ,gBAAc,OAAOR,EAAW9I,KAAIgJ,GAAKA,EAAE,O,mECtCvD7L,EAAA,Y,kCCAAA,EAAA,Y,kCCoBO,SAASoM,IAIf,MAAM5J,EAAuC,CAC5CpC,UAAW,KACXiB,IAAK,KACLS,aAAegE,GACdtD,EAAMnB,IAAQyE,EAAMzE,IACpBmB,EAAMpC,UAAY0F,EAAMC,aAG1B,OAAOvD,EAmBD,SAAS6J,IAIf,MAAM7J,EAAwC,CAC7C8J,KAAM,GACNxK,aAAeyK,EAAczG,GAEd,MAATA,UACGtD,EAAM8J,KAAMC,GACnB/J,EAAM8J,KAAKzF,UAEA0F,KAAS/J,EAAM8J,MAC1B9J,EAAM8J,KAAMC,GAAQnM,UAAY0F,EAAMC,WACtCvD,EAAM8J,KAAMC,GAAQlL,IAASyE,EAAMzE,KAGnCmB,EAAM8J,KAAMC,GAAU,CACrBlL,IAAQyE,EAAMzE,IACdjB,UAAY0F,EAAMC,cAKtB,OAAOvD,E,4JC3ER,IAAAvC,EAAAD,EAAA,S,WAKO,SAASwM,EAAUpD,IAEzB,EAAAnJ,EAAAI,sBAAqBqI,eAAe9H,KAAMwI,GAGpC,SAASqD,EAAYrD,IAE3B,EAAAnJ,EAAAI,sBAAqBsI,iBAAiB/H,KAAMwI","sources":["src/reflex/index.ts","src/reflex/state.ts","src/reflex/diff.ts","src/reflex/common.ts","src/reflex/jsx.ts","src/reflex/component.ts","src/reflex/render.ts","src/reflex/observable.ts","node_modules/@zouloux/signal/dist/index.es2020.mjs","node_modules/@zouloux/signal/dist/signal.es2020.mjs","node_modules/@zouloux/signal/dist/state-signal.es2020.mjs","node_modules/@zouloux/signal/dist/observable.es2020.mjs","src/reflex/ref.ts","src/reflex/lifecycle.ts"],"sourcesContent":["/// <reference lib=\"dom\" />\n// ----------------------------------------------------------------------------- IMPORT / EXPORT\n\n/**\n * REFLEX JS\n *\n * - Reflex Core\n * \t\t- Core\n * \t\t- Polyfills\n * \t\t- Signal + Observer\n * \t\t- YADL\n * \t\t- Utils\n * - Reflex Components\n * \t\t- Reflex View (vdom + web components)\n * \t\t- Reflex Store\n * \t\t\t- Regular store / Async store or one big store well-made\n * \t\t- Reflex Router\n * \t\t\t- Based on Reflex Store\n * \t\t- Reflex Tween ?\n *\t\t- Reflex Toolkit\n *\t\t\t- Hooks\n *\t\t\t- Responsive\n *\t\t\t- Inputs\n *\t\t\t- Cursor\n *\t\t\t- Sound\n *\t\t\t- Viewport\n *\t\t- Reflex UI Kit\n *\t\t\t- mixins\n *\t\t\t- UI Kit\n *\t\t\t- Components ( Slideshow / Menu / Player ... )\n * - Reflex Server\n *\n */\n\n/**\n * FEATURES :\n *\n * - Basic v-dom\n * \t ✔ Create / remove elements\n * \t ✔ Set / remove attributes\n * \t ✔ Set / remove event listeners\n * \t ✔ Reuse previous components, do not trash everything everytime\n * \t ✔ innerHTML\n *   ✔ Class as string or array filtered with booleans\n *   \t- Optimize class when does not changes, is it possible ?\n *   ✔ Style as object only\n *   \t- Optimize style when does not changes, is it possible ?\n *\n * - Advanced v-dom\n *   ✔ Move elements and keep track of dom elements with keyed virtual nodes\n *   \t✔ Add to top\n *   \t✔ Add to bottom\n *   \t✔ Remove from top\n *   \t✔ Remove from bottom\n *   \t✔ Insert in the middle\n *      ✔ Remove from the middle\n *      ✔ Basic swap\n *  \tX Optimized Swap\n *  \t\t- Do 2 operations, should do only one\n *   ✔ Keep track of component instances\n *   ✔ Remove subtrees recursively\n *   ✔ Sub tree rendering\n *   ✔ Rendering optimization (like memo and skip)\n *\n * - Reactive\n *   ✔ Dom ref / component ref\n *   ✔ Factory helpers (like hooks), find name and prefix\n *   ✔ Var in ref as let ! Yeah\n *   ✔ States / observers\n *   ✔ Stores\n *   ✔ Mount / Unmount\n *   ✔ Updated + Props\n *\n * - Advanced Reactive\n *   - Multi refs in for loops and stuff, need to keep correct indexes even when moving\n *   - Factory Errors / Component errors ( try catch on instance + render etc )\n *   - Async states ! With cancellation\n *   - Fetch hook with race condition management + states + cache + cancellable\n *   - Imperative handles\n *\n * - Types\n * \t - Basic JSX Type\n * \t - Render and component return JSX Types\n * \t - Props types\n *\n * - Release\n * \t - Optimize\n * \t - Benchmark\n * \t - Docs\n * \t - Release\n *\n * V2 :\n * - Advanced Hot Module reloading with state keeping automagically\n */\n\n// NOTE : Avoid glob exports from which insert an helper\n// Unzipped is smaller with glob but bigger when zipped\nexport { state, asyncState } from \"./state\"\nexport { ref, refs, IRef, IRefs } from \"./ref\"\nexport { mounted, unmounted, changed } from \"./lifecycle\"\nexport { render, invalidateComponent } from \"./render\"\n// Also export createElement for JSX pragma React\nexport { h, h as createElement } from \"./jsx\"\n","import { getHookedComponent } from \"./diff\";\nimport { invalidateComponent } from \"./render\";\nimport {\n\tcreateAsyncObservable, createStateObservable, IAsyncObservable,\n\tIStateObservable, TInitialValue\n} from \"./observable\";\n\n// ----------------------------------------------------------------------------- STATE\n\nexport function state <GType> ( initialValue?:TInitialValue<GType> ):IStateObservable<GType> {\n\tconst component = getHookedComponent()\n\tconst observable = createStateObservable( initialValue, () => invalidateComponent( component ) )\n\tcomponent._observables.push( observable )\n\treturn observable\n}\n\n// ----------------------------------------------------------------------------- ASTNC STATE\n\nexport function asyncState <GType> ( initialValue?:TInitialValue<GType> ):IAsyncObservable<GType> {\n\tconst component = getHookedComponent()\n\t// TODO : Implement this\n\tconst observable = createAsyncObservable( initialValue, () => invalidateComponent( component ) )\n\t// TODO : We may need cancellable Promises. Maybe just use reject ? And throw errors in legacy mode.\n\tcomponent._observables.push( observable )\n\treturn observable\n}","import {\n\t_TEXT_NODE_TYPE_NAME, RenderDom, RenderFunction,\n\tVNode, VNodeDomType, VTextNode, ComponentFunction,\n\tComponentReturn, _flattenChildren, _isFunction\n} from \"./common\";\nimport { cloneVNode } from \"./jsx\";\nimport { IInternalRef, IInternalRefs } from \"./ref\";\nimport { ComponentInstance, createComponentInstance, recursivelyUpdateMountState } from \"./component\";\n\n/**\n * TODO : Errors\n * - Disallow a component render function to return a component as main node !\n * \t\t\t() => <OtherComponent /> <- Forbidden\n * - Disallow a component which render an array\n * \t\t\t() => [<div />, <div />] <- Forbidden\n */\n\n// ----------------------------------------------------------------------------- CONSTANTS\n\n// Virtual node object is injected into associated dom elements with this name\nexport const _DOM_PRIVATE_VIRTUAL_NODE_KEY = \"__v\"\n\n// Attached listeners to a dom element are stored in this array\nexport const _DOM_PRIVATE_LISTENERS_KEY = \"__l\"\n\n// Stolen from Preact, to check if a style props is non-dimensional (does not need to add a unit)\nconst _IS_NON_DIMENSIONAL_REGEX = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n\n// Check if an event is a capture one\nconst _CAPTURE_REGEX = /Capture$/\n\n// ----------------------------------------------------------------------------- CURRENT SCOPED COMPONENT\n\n// We store current component in factory phase for hooks\nlet _hookedComponent:ComponentInstance = null\nexport function getHookedComponent ():ComponentInstance {\n\tif ( !_hookedComponent && process.env.NODE_ENV !== \"production\" )\n\t\t// throw new ReflexError(`getHookedComponent // Cannot use a factory hook outside of a factory component.`)\n\t\tthrow new Error(`Reflex - getHookedComponent // Cannot use a factory hook outside of a factory component.`)\n\treturn _hookedComponent\n}\n\n// ----------------------------------------------------------------------------- COMMON\n\nfunction getEventNameAndKey ( name:string, dom:Element ) {\n\t// Note : Capture management stolen from Preact, thanks\n\tconst useCapture = name !== ( name = name.replace(_CAPTURE_REGEX, '') );\n\t// Infer correct casing for DOM built-in events:\n\tconst eventName = ( name.toLowerCase() in dom ? name.toLowerCase() : name ).slice(2)\n\t// Create unique key for this event\n\tconst eventKey = eventName + (useCapture ? 'C' : '')\n\treturn { eventName, eventKey, useCapture }\n}\n\n// Stolen from Preact, attach some style à key / value to a dom element\nfunction setStyle ( style:CSSStyleDeclaration, key:string, value:string|null ) {\n\tif (key[0] === '-')\n\t\tstyle.setProperty(key, value);\n\telse if (value == null)\n\t\tstyle[key] = '';\n\t// FIXME : IS_NON_DIMENSIONAL_REGEX -> Is it really necessary ?\n\telse if ((typeof value)[0] != 'n' || _IS_NON_DIMENSIONAL_REGEX.test(key))\n\t\tstyle[key] = value;\n\telse\n\t\tstyle[key] = value + 'px';\n}\n\nfunction updateNodeRef ( node:VNode ) {\n\tif ( !node._ref ) return;\n\t// Ref as refs\n\tif ( 'list' in node._ref ) {\n\t\t// FIXME : Type\n\t\t// FIXME : Keep track of index ? Do it from diffChildren maybe ?\n\t\t( node._ref as IInternalRefs ).setFromVNode( 0, node as any )\n\t} else {\n\t\t// FIXME : Type\n\t\t( node._ref as IInternalRef ).setFromVNode( node as any )\n\t}\n}\n\n// Shallow compare two objects, applied only for props between new and old virtual nodes.\n// Will not compare \"children\" which is always different\n// https://esbench.com/bench/62a138846c89f600a5701904\nconst shallowPropsCompare = ( a:object, b:object ) => (\n\t// Same amount of properties ?\n\tObject.keys(a).length === Object.keys(b).length\n\t// Every property exists in other object ?\n\t// Never test \"children\" property which is always different\n\t&& Object.keys(a).every( key => key === \"children\" || (b.hasOwnProperty(key) && a[key] === b[key]) )\n)\n\n// ----------------------------------------------------------------------------- DIFF ELEMENT\n\nexport function diffElement ( newNode:VNode, oldNode:VNode ) {\n\t// console.log(\"diffElement\", newNode, oldNode)\n\tconst isTextNode = newNode.type == _TEXT_NODE_TYPE_NAME\n\t// Get dom element from oldNode or create it\n\tconst dom:RenderDom = (\n\t\toldNode ? oldNode.dom : (\n\t\t\tisTextNode\n\t\t\t? document.createTextNode( (newNode as VTextNode).props.value )\n\t\t\t: document.createElement( newNode.type as VNodeDomType )\n\t\t)\n\t)\n\t// Update text contents\n\tif ( isTextNode && oldNode ) {\n\t\tconst { value } = (newNode as VTextNode).props;\n\t\t// Only when content has changed\n\t\tif ( value != (dom as Text).nodeValue )\n\t\t\t( dom as Text ).nodeValue = value\n\t}\n\t// Text nodes does not have attributes or events\n\tif ( isTextNode ) return dom\n\t// Remove attributes which are removed from old node\n\toldNode && Object.keys( oldNode.props ).map( name => {\n\t\t// Do not process children and remove only if not in new node\n\t\tif ( name == \"children\" ) return\n\t\tif ( name in newNode.props && newNode.props[ name ] === oldNode.props[ name ] )\n\t\t\treturn\n\t\t// Insert HTML directly without warning\n\t\tif ( name == \"innerHTML\" )\n\t\t\t( dom as Element ).innerHTML = \"\" // FIXME : Maybe use delete or null ?\n\t\t\t// Events starts with \"on\". On preact this is optimized with [0] == \"o\"\n\t\t// But recent benchmarks are pointing to startsWith usage as faster\n\t\telse if ( name.startsWith(\"on\") ) {\n\t\t\tconst { eventName, eventKey, useCapture } = getEventNameAndKey( name, dom as Element );\n\t\t\tdom.removeEventListener( eventName, dom[ _DOM_PRIVATE_LISTENERS_KEY ][ eventKey ], useCapture )\n\t\t}\n\t\t// Other attributes\n\t\telse {\n\t\t\t( dom as Element ).removeAttribute( name )\n\t\t}\n\t})\n\t// Update props\n\tObject.keys( newNode.props ).map( name => {\n\t\tif ( name == \"children\" ) return\n\t\tlet value = newNode.props[ name ];\n\t\t// Do not continue if attribute or event did not change\n\t\tif ( oldNode && name in oldNode.props && oldNode.props[ name ] === value )\n\t\t\treturn;\n\t\t// Insert HTML directly without warning\n\t\tif ( name == \"innerHTML\" )\n\t\t\t( dom as Element ).innerHTML = value\n\t\t// Events starts with \"on\". On preact this is optimized with [0] == \"o\"\n\t\t// But recent benchmarks are pointing to startsWith usage as faster\n\t\telse if ( name.startsWith(\"on\") ) {\n\t\t\tconst { eventName, eventKey, useCapture } = getEventNameAndKey( name, dom as Element );\n\t\t\t// Init a collection of handlers on the dom object as private property\n\t\t\tdom[ _DOM_PRIVATE_LISTENERS_KEY ] ??= new Map();\n\t\t\t// Store original listener to be able to remove it later\n\t\t\tdom[ _DOM_PRIVATE_LISTENERS_KEY ][ eventKey ] = value;\n\t\t\t// And attach listener\n\t\t\tdom.addEventListener( eventName, value, useCapture )\n\t\t}\n\t\t// Other attributes, just set right on the dom element\n\t\telse {\n\t\t\t// className as class for non jsx components\n\t\t\tif ( name == \"className\" )\n\t\t\t\tname = \"class\"\n\t\t\t// Manage class as arrays\n\t\t\tif ( name == \"class\" && Array.isArray( value ) )\n\t\t\t\tvalue = value.filter( v => v !== true && !!v ).join(\" \").trim()\n\t\t\t// Manage style as object only\n\t\t\telse if ( name == \"style\" && (typeof value)[0] == \"o\" )\n\t\t\t\t// FIXME : Can it be optimized ? Maybe only setStyle when needed ?\n\t\t\t\treturn Object.keys( value ).map(\n\t\t\t\t\tk => setStyle( (dom as HTMLElement).style, k, value[k] )\n\t\t\t\t);\n\t\t\t// Remove falsy values\n\t\t\telse if ( value == false )\n\t\t\t\treturn;\n\t\t\t// FIXME : What about checked / disabled / autoplay ...\n\t\t\t// Set new attribute value\n\t\t\t( dom as Element ).setAttribute( name, value )\n\t\t}\n\t})\n\treturn dom;\n}\n\n// ----------------------------------------------------------------------------- DIFF CHILDREN\n\n/**\n * Note about performances\n * - Very important, avoid loops in loops ! Prefer 4 static loops at top level\n *   rather than 2 nested loops. n*4 is lower than n^n !\n */\nexport function diffChildren ( newParentNode:VNode, oldParentNode?:VNode ) {\n\t// console.log(\"Diff children\", newParentNode, oldParentNode)\n\t// Target new and old children.\n\tconst newChildren = newParentNode.props.children?.flat()\n\tconst oldChildren = oldParentNode?.props.children?.flat()\n\t// FIXME : If new does not have children but old does, we need to destroy old children components instances\n\tif ( !newChildren ) return;\n\tconst parentDom = newParentNode.dom as Element\n\t// Create key array on parent node to register keyed children\n\t// This will allow us to find any child by its key directly without\n\t// having to search for it\n\tnewParentNode._keys = new Map()\n\tconst registerKey = c => {\n\t\tif ( c?.key ) newParentNode._keys[ c.key ] = c\n\t}\n\t// This is a new parent node (no old), so no diffing\n\t// we juste process and add every child node\n\tif ( !oldChildren ) {\n\t\tnewChildren.map( newChildNode => {\n\t\t\tif (!newChildNode) return;\n\t\t\tdiffNode( newChildNode )\n\t\t\tparentDom.appendChild( newChildNode.dom )\n\t\t\t// Register this child with its key on its parent\n\t\t\tregisterKey( newChildNode )\n\t\t})\n\t\treturn;\n\t}\n\t// Map all new children keys into the keys register to avoid to use find\n\t// when searching for removed nodes\n\t// NOTE : About performances : 1st non-nested loop\n\tnewChildren.map( registerKey )\n\t// Check if an old keyed node has been removed and get which index are offset after removal\n\t// NOTE : About performances : 2nd non-nested loop\n\tconst lostIndexes = oldChildren.map(\n\t\toldChild => !!(oldChild?.key && !newParentNode._keys[oldChild.key] )\n\t)\n\t// Otherwise we need to compare between old and new tree\n\tconst oldParentKeys = oldParentNode._keys\n\tlet collapseCount = 0\n\t// NOTE : About performances : 3rd non-nested loop\n\tnewChildren.map( (newChildNode, i) => {\n\t\t// Collapsed corresponding index between old and new nodes\n\t\t// To be able to detect moves or if just collapsing because a top sibling\n\t\t// has been removed\n\t\tif ( lostIndexes[i] )\n\t\t\tcollapseCount ++\n\t\t/** REMOVED **/\n\t\t// If falsy, it's surely a child that has been removed with a ternary or a boolean\n\t\t// Do nothing else and do not mark old node to keep, so it will be removed\n\t\tif ( !newChildNode )\n\t\t\treturn;\n\t\t// Has key, same key found in old, same type on both\n\t\t/** MOVE & UPDATE KEYED CHILD **/\n\t\tif (\n\t\t\tnewChildNode.key\n\t\t\t&& oldParentKeys[ newChildNode.key ]\n\t\t\t&& oldParentKeys[ newChildNode.key ].type == newChildNode.type\n\t\t) {\n\t\t\tconst oldNode = oldParentKeys[ newChildNode.key ]\n\t\t\tdiffNode( newChildNode, oldNode )\n\t\t\toldNode._keep = true;\n\t\t\t// Check if index changed, compare with collapsed index to detect moves\n\t\t\tconst collapsedIndex = i + collapseCount\n\t\t\t// FIXME : Should do 1 operation when swapping positions, not 2\n\t\t\t// FIXME : Perf, is indexOf quick ? Maybe store every indexes in an array ?\n\t\t\tif ( oldChildren.indexOf( oldNode ) != collapsedIndex )\n\t\t\t\tparentDom.insertBefore( newChildNode.dom, parentDom.children[ i ] )\n\t\t}\n\t\t// Has key, but not found in old\n\t\t/** CREATE **/\n\t\telse if ( newChildNode.key && !oldParentKeys[ newChildNode.key ] ) {\n\t\t\tdiffNode( newChildNode )\n\t\t\tparentDom.insertBefore( newChildNode.dom, parentDom.children[ i ] )\n\t\t\tcollapseCount --\n\t\t}\n\t\t// Found at same index, with same type.\n\t\t// Old node does not have a key.\n\t\t/** UPDATE IN PLACE **/\n\t\telse if ( i in oldChildren && oldChildren[ i ] && oldChildren[ i ].type == newChildNode.type ) {\n\t\t\tconst oldNode = oldChildren[ i ]\n\t\t\tdiffNode( newChildNode, oldNode )\n\t\t\toldNode._keep = true;\n\t\t}\n\t\t// Not found\n\t\t/** CREATE **/\n\t\telse {\n\t\t\tdiffNode( newChildNode )\n\t\t\tparentDom.insertBefore( newChildNode.dom, parentDom.children[ i ] )\n\t\t\tcollapseCount --\n\t\t}\n\t})\n\t// Remove old children which are not reused\n\t// NOTE : About performances : 4th non-nested loop\n\toldChildren.map( oldChildNode => {\n\t\tif ( oldChildNode && !oldChildNode._keep ) {\n\t\t\t// Call unmount handlers\n\t\t\trecursivelyUpdateMountState( oldChildNode, false );\n\t\t\t// Remove ref\n\t\t\tconst { dom } = oldChildNode\n\t\t\toldChildNode.dom = null;\n\t\t\tupdateNodeRef( oldChildNode )\n\t\t\tparentDom.removeChild( dom )\n\t\t}\n\t})\n}\n\n// ----------------------------------------------------------------------------- DIFF NODE\n\nfunction renderComponentNode <GReturn = ComponentReturn> ( node:VNode<null, ComponentFunction>, component:ComponentInstance ) :GReturn {\n\t// Tie component and virtual node\n\tcomponent.vnode = node\n\tnode._component = component\n\t// Select hooked component\n\t_hookedComponent = component;\n\t// FIXME: Before render handlers ?\n\t// FIXME: Optimize rendering with a hook ?\n\t// Execute rendering\n\tconst result = (component._render ?? node.type as RenderFunction)\n\t\t.apply( component, [ component._propsProxy.value ])\n\t// Unselect hooked component\n\t_hookedComponent = null\n\treturn result as GReturn\n}\n\nexport function diffNode ( newNode:VNode, oldNode?:VNode ) {\n\t// IMPORTANT : Here we clone node if we got the same instance\n\t// \t\t\t   Otherwise, altering props.children after render will fuck everything up\n\t// Clone identical nodes to be able to diff them\n\tif ( oldNode && oldNode === newNode )\n\t\tnewNode = cloneVNode( oldNode )\n\t// Transfer component instance from old node to new node\n\tlet component:ComponentInstance = oldNode?._component\n\t// We may need a new component instance\n\tlet renderResult:VNode\n\tif ( !component && _isFunction(newNode.type) ) {\n\t\t// Create component instance (without new keyword for better performances)\n\t\tcomponent = createComponentInstance( newNode as VNode<null, ComponentFunction> )\n\t\t// Execute component's function and check what is returned\n\t\tconst result = renderComponentNode( newNode as VNode<null, ComponentFunction>, component )\n\t\t// This is a factory component which return a render function\n\t\tif ( _isFunction(result) ) {\n\t\t\tcomponent._render = result as RenderFunction\n\t\t\tcomponent.isFactory = true\n\t\t}\n\t\t// This is pure functional component which returns a virtual node\n\t\telse if ( (typeof result)[0] == \"o\" && \"type\" in result ) {\n\t\t\tcomponent._render = newNode.type as RenderFunction\n\t\t\tcomponent.isFactory = false\n\t\t\trenderResult = result\n\t\t}\n\t}\n\tlet dom:RenderDom\n\t// Virtual node is a dom element\n\tif ( !component ) {\n\t\tnewNode.dom = dom = diffElement( newNode, oldNode )\n\t}\n\t// Virtual node is a component\n\telse {\n\t\t// FIXME : Is it a good idea to shallow compare props on every changes by component ?\n\t\t// \t\t\t-> It seems to be faster than preact + memo with this 👀, check other cases\n\t\t// TODO : Maybe do not shallow by default but check if component got an \"optimize\" function\n\t\t//\t\t\twhich can be implemented with hooks. We can skip a lot with this !\n\t\t// FIXME : Does not work if props contain dynamic arrow functions :(\n\t\t//\t\t\t<Sub onEvent={ e => handler(e, i) } />\n\t\t//\t\t\tHere the handler is a different ref at each render\n\t\t// If props did not changed between old and new\n\t\t// Only optimize pure components, factory components mau have state so are not pure\n\t\tif (\n\t\t\t// If pure functional component has not already been rendered\n\t\t\t!renderResult\n\t\t\t// Need to be a component update, on a pure functional component,\n\t\t\t&& oldNode && !component.isFactory // && !component.isDirty\n\t\t\t// New component isn't marked as not pure\n\t\t\t&& newNode.props.pure !== false // FIXME : Rename it forceRefresh={ true } ?\n\t\t\t// Cannot optimize components which have children properties\n\t\t\t// Because parent component may have altered rendering of injected children\n\t\t\t&& newNode.props.children.length === 0\n\t\t\t// Do shallow compare\n\t\t\t&& shallowPropsCompare(newNode.props, oldNode.props)\n\t\t) {\n\t\t\t// FIXME : Weirdly, it seems to optimize not all components\n\t\t\t//\t\t\tEx : click on create 1000 several times and watch next console log\n\t\t\t// console.log(\"OPTIMIZE\")\n\t\t\t// Do not re-render, just get children and dom from old node\n\t\t\t// newNode.props.children = [ ...oldNode.props.children ]\n\t\t\tnewNode.props.children = oldNode.props.children\n\t\t\tnewNode.dom = dom = oldNode.dom\n\t\t}\n\t\t// Not already rendered, and not optimization possible. Render now.\n\t\telse if ( !renderResult ) {\n\t\t\tcomponent._propsProxy.set( newNode.props )\n\t\t\trenderResult = renderComponentNode<VNode>( newNode as VNode<null, ComponentFunction>, component )\n\t\t}\n\t\t// We rendered something (not reusing old component)\n\t\tif ( renderResult ) {\n\t\t\t// Apply new children list to the parent component node\n\t\t\tnewNode.props.children = _flattenChildren( renderResult )\n\t\t\t// Diff rendered element\n\t\t\tnewNode.dom = dom = diffElement( renderResult, oldNode )\n\t\t\t// Assign ref of first virtual node to the component's virtual node\n\t\t\tnewNode._ref = renderResult._ref\n\t\t}\n\t\t// Tie up node and component\n\t\tnewNode._component = component\n\t\tcomponent.vnode = newNode as any\n\t\t// Component is clean and rendered now\n\t\tcomponent._isDirty = false\n\t}\n\t// Update ref on node\n\tupdateNodeRef( newNode )\n\t// Diff children of this element (do not process text nodes)\n\tif ( dom instanceof Element )\n\t\tdiffChildren( newNode, oldNode )\n\t// If component is not mounted yet, mount it recursively\n\tif ( component && !component.isMounted )\n\t\trecursivelyUpdateMountState( newNode, true )\n\t// Execute after render handlers\n\tcomponent?._renderHandlers.map( h => h() )\n}\n","import { IRef, IRefs } from \"./ref\";\nimport { ComponentInstance } from \"./component\";\n\n// ----------------------------------------------------------------------------- TYPES\n\n// Declare global JSX override hack\n// declare global {\n// \tnamespace JSX {\n//\n// \t}\n// }\n\n// ----------------------------------------------------------------------------- CONSTANTS\n\n// Name of private node types which should not be created with JSX\n\nexport const _TEXT_NODE_TYPE_NAME = \"#T\"\nexport const _ROOT_NODE_TYPE_NAME = \"#R\"\n\n// ----------------------------------------------------------------------------- ERRORS\n\n//export class ReflexError extends Error {}\n\n// ----------------------------------------------------------------------------- POLYFILLS\n\n// TODO : Into ecma-core + inline in bundle\nexport const _microtask = ( window.queueMicrotask ?? ( h => window.setTimeout( h, 0 )) )\n\n// ----------------------------------------------------------------------------- UTILS\n\n// Force a list or a lonely item to be an array with the same type\n// TODO : Into ecma-core + inline in bundle\nexport const _forceArray = <G>( item:G|G[] ):G[] => Array.isArray( item ) ? item : [ item ]\n\n\nexport const _isFunction = fn => (typeof fn)[0] == \"f\"\n\nexport function _flattenChildren ( vnode:VNode ) {\n\t// Re-assign flattened array to the original virtual node, and return it\n\treturn vnode.props.children = (vnode.props?.children?.flat() ?? [])\n}\n\n// ----------------------------------------------------------------------------- INTERNAL - CREATE COMPONENT\n\nexport type RenderDom = Element|Text\n\n// FIXME : Cannot be VNode[] in current implementation.\n// FIXME : Cannot be string in current implementation.\nexport type RenderFunction = () => VNode\nexport type FunctionalComponent = RenderFunction\nexport type ComponentReturn = RenderFunction|VNode\nexport type FactoryComponent = () => RenderFunction\nexport type ComponentFunction = FunctionalComponent|FactoryComponent\n\nexport type LifecycleHandler <GReturn = void> = (...rest) => GReturn\nexport type MountHandler = LifecycleHandler|LifecycleHandler<LifecycleHandler>\n\n// ----------------------------------------------------------------------------- JSX H / CREATE ELEMENT\n\nexport type VNodeDomType = keyof (HTMLElementTagNameMap|SVGElementTagNameMap)\nexport type InternalVNodeTypes = typeof _ROOT_NODE_TYPE_NAME | typeof _TEXT_NODE_TYPE_NAME\n\nexport interface VNodeBaseProps {\n\tchildren\t?:VNode[],\n\tkey\t\t\t?:string\n\tref\t\t\t?:IRef|IRefs\n\tpure\t\t?:boolean\n}\n\nexport interface VNode <\n\tGProps \t= VNodeBaseProps,\n\tGType \t= ( VNodeDomType | InternalVNodeTypes | ComponentFunction ),\n> {\n\ttype\t\t\t:GType\n\tprops\t\t\t:GProps\n\tkey\t\t\t\t:string\t// Allow numbers ?\n\tdom\t\t\t\t?:RenderDom\n\t_keys\t\t\t?:Map<string, VNode>\n\t_ref\t\t\t?:IRef | IRefs\n\t_component\t\t?:ComponentInstance\n\t_keep\t\t\t?:boolean\n}\n\nexport interface VTextNode extends VNode<{value:string}> {\n\ttype\t\t: typeof _TEXT_NODE_TYPE_NAME\n}\n\nexport type VNodeOrVNodes = VNode|VNode[]\n","import { _TEXT_NODE_TYPE_NAME, VNode } from \"./common\";\n\n// NOTE : Keep it in a function and do not inline this\n// It seems to be V8 optimized. @see Preact source code\nexport function createVNode ( type, props, key?, ref? ):VNode {\n\treturn { type: type, props: props, key: key, _ref: ref }\n}\n\nexport function cloneVNode ( vnode:VNode ) {\n\treturn {\n\t\t...vnode,\n\t\t// IMPORTANT : also clone props object\n\t\tprops: { ...vnode.props }\n\t}\n}\n\n\nexport function h ( type, props, ...children ) {\n\t// Remove debug properties\n\t// FIXME : Keep them in debug mode ? But in vnode not in props.\n\tlet nodeProps:any = {}\n\tlet key, ref\n\tfor ( let i in props ) {\n\t\tconst value = props[ i ]\n\t\t// Set apart key and ref\n\t\tif ( i == \"key\" )\n\t\t\tkey = value\n\t\telse if ( i == \"ref\" )\n\t\t\tref = value\n\t\t// Remove __self and __source debug props\n\t\telse if ( !i.startsWith('__') )\n\t\t\tnodeProps[i] = value\n\t}\n\t// Inject children in props\n\tnodeProps.children = children.map( child => (\n\t\t// Convert string and number children to text virtual nodes\n\t\t( [\"s\", \"n\"].indexOf( (typeof child)[0] ) != -1 )\n\t\t? createVNode( _TEXT_NODE_TYPE_NAME, { value: '' + child })\n\t\t// Otherwise keep child generated by JSX\n\t\t: child\n\t))\n\treturn createVNode( type, nodeProps, key, ref )\n}\n\n\n\n// export function h ( type, props, ...children ) {\n// \t// Remove debug properties\n// \t// FIXME : Keep them in debug mode ? But in vnode not in props.\n// \tdelete props.__self\n// \tdelete props.__source\n// \t// Extract key and ref from props\n// \tconst { key, ref, ...nodeProps } = props\n// \t// Inject children in props\n// \tnodeProps.children = ( children ?? [] ).map( child => (\n// \t\t// Convert string and number children to text virtual nodes\n// \t\t( [\"string\", \"number\"].indexOf( typeof child ) !== -1 )\n// \t\t\t? createVNode( _TEXT_NODE_TYPE_NAME, { value: child + '' })\n// \t\t\t// Otherwise keep child generated by JSX\n// \t\t\t: child\n// \t))\n// \treturn createVNode( type, nodeProps, key, ref )\n// }","import {\n\tComponentFunction, _flattenChildren, LifecycleHandler,\n\tMountHandler, RenderFunction,\n\t_TEXT_NODE_TYPE_NAME, VNode, _isFunction\n} from \"./common\";\nimport { IStateObservable } from \"@zouloux/signal\";\n\n// ----------------------------------------------------------------------------- TYPES\n\nexport interface ComponentInstance { // FIXME : Generics ?\n\tvnode\t\t\t\t:VNode<null, ComponentFunction>\n\tname\t\t\t\t:string\n\tisFactory\t\t\t?:boolean\n\tisMounted\t\t\t:boolean;\n\t_isDirty\t\t\t?:boolean\n\t_render\t\t\t\t?:RenderFunction\n\t_propsProxy\t\t\t?:IPropsProxy<any>\n\t_mountHandlers\t\t:MountHandler[]\n\t_renderHandlers\t\t:LifecycleHandler[]\n\t_unmountHandlers\t:LifecycleHandler[]\n\t_observables\t\t:IStateObservable<any>[]\n\t// TODO : Imperative handlers ?\n}\n\n// ----------------------------------------------------------------------------- CREATE COMPONENT INSTANCE\n\n// Optimize it in a function @see jsx.ts/createVNode()\nexport function createComponentInstance ( vnode:VNode<null, ComponentFunction> ):ComponentInstance {\n\treturn {\n\t\tvnode,\n\t\t_propsProxy: createPropsProxy( vnode.props ),\n\t\t_isDirty: false,\n\t\tisMounted: false,\n\t\tname: vnode.type.name,\n\t\t_mountHandlers: [],\n\t\t_renderHandlers: [],\n\t\t_unmountHandlers: [],\n\t\t_observables: [],\n\t}\n}\n\n// ----------------------------------------------------------------------------- PROPS PROXY\n// Props proxy exists because we need a way to get updated props in a factory\n// component. Because factory function is executed once, props object passed\n// as first argument cannot be updated. Proxy helps us here because it will\n// allow us to mock props but with every props updated.\n// A caveat is that props is not iterable because proxy is a dynamic key / value\n// object. Not really concerning because it makes no sense to iterate over\n// a props object.\n\nexport interface IPropsProxy <GType> {\n\treadonly value:GType\n\tset ( newValue:GType ) : void\n}\n\nfunction createPropsProxy <GProps> ( props:GProps ) : IPropsProxy<GProps> {\n\tconst proxy = new Proxy({}, {\n\t\t// When request a prop, check on props object if it exists\n\t\tget ( target:{}, propName:string|symbol ):any {\n\t\t\treturn ( propName in props ? props[ propName ] : void 0 )\n\t\t},\n\t\t// Disallow set on props\n\t\tset () {\n\t\t\tif ( process.env.NODE_ENV == \"production\" ) return false\n\t\t\tthrow new Error(`Reflex - PropsProxy.set // Setting values to props manually is not allowed.`)\n\t\t}\n\t})\n\treturn {\n\t\t// Get the proxy object typed as a GProps object\n\t\tget value () { return proxy as GProps },\n\t\t// This method will set new props object (we override first argument of createPropsProxy)\n\t\tset ( newProps:GProps ) { props = newProps }\n\t}\n}\n\n// ----------------------------------------------------------------------------- MOUNT / UNMOUNT\n\nexport function mountComponent ( component:ComponentInstance ) {\n\t// Call every mount handler and store returned unmount handlers\n\tcomponent._mountHandlers.map( handler => {\n\t\tconst mountedReturn = handler.apply( component, [] );\n\t\tif ( _isFunction(mountedReturn) )\n\t\t\tcomponent._unmountHandlers.push( mountedReturn )\n\t})\n\t// Reset mount handlers, no need to keep them\n\tcomponent._mountHandlers = []\n\tcomponent.isMounted = true;\n}\n\nexport function unmountComponent ( component:ComponentInstance ) {\n\tcomponent._unmountHandlers.map( h => h.apply( component, [] ) )\n\tcomponent._observables.map( o => o.dispose() )\n\t// FIXME : Do we need to do this ? Is it efficient or is it just noise ?\n\t//delete component.vnode\n\t// delete component.propsProxy\n\tdelete component._mountHandlers;\n\tdelete component._renderHandlers;\n\tdelete component._unmountHandlers;\n\tdelete component._observables\n\tcomponent.isMounted = false;\n}\n\nexport function recursivelyUpdateMountState ( node:VNode, doMount:boolean ) {\n\tif ( node.type == _TEXT_NODE_TYPE_NAME ) return\n\t_flattenChildren( node ).map( c => c && recursivelyUpdateMountState(c, doMount) )\n\tif ( node._component )\n\t\tdoMount ? mountComponent( node._component ) : unmountComponent( node._component )\n}","import { _ROOT_NODE_TYPE_NAME, _forceArray, VNodeOrVNodes, _microtask } from \"./common\";\nimport { diffChildren, diffNode, _DOM_PRIVATE_VIRTUAL_NODE_KEY } from \"./diff\";\nimport { createVNode } from \"./jsx\";\nimport { ComponentInstance } from \"./component\";\n\n// ----------------------------------------------------------------------------- RENDER\n\nexport function render ( rootNode:VNodeOrVNodes, parentElement:HTMLElement ) {\n\t// When using render, we create a new root node to detect new renders\n\t// This node is never rendered, we just attach it to the parentElement and render its children\n\tconst root = createVNode( _ROOT_NODE_TYPE_NAME, { children: _forceArray( rootNode ) })\n\troot.dom = parentElement\n\tdiffChildren( root, parentElement[ _DOM_PRIVATE_VIRTUAL_NODE_KEY ] )\n\tparentElement[ _DOM_PRIVATE_VIRTUAL_NODE_KEY ] = root\n}\n\n// ----------------------------------------------------------------------------- INVALIDATION\n\nlet componentsToUpdate:ComponentInstance[] = []\nfunction updateDirtyComponents () {\n\tlet p\n\tif ( process.env.NODE_ENV !== \"production\" )\n\t\tp = require(\"./debug\").trackPerformances(\"Update dirty components\")\n\t// TODO : Update with depth ! Deepest first ? Or last ?\n\tcomponentsToUpdate.map( component => {\n\t\tdiffNode( component.vnode, component.vnode )\n\t})\n\tcomponentsToUpdate = []\n\tp && p();\n}\n\nexport function invalidateComponent ( component:ComponentInstance ) {\n\t// Queue rendering before end of frame\n\tif ( componentsToUpdate.length === 0 )\n\t\t_microtask( updateDirtyComponents );\n\t// Invalidate this component once\n\tif ( component._isDirty ) return;\n\tcomponent._isDirty = true\n\t// Store it into the list of dirty components\n\tcomponentsToUpdate.push( component )\n}\n\n// ----------------------------------------------------------------------------- REGISTER WEB-COMPONENTS\n\n// TODO : Web components ! Check how lit and preact webcomponents works\n//\t\t\t- Register web-components with ComponentName to <component-name />\n//  \t\t- Update properties when changed in DOM\n//  \t\t\t- Need translation (detect numbers, maybe json for array and objects ?)\n//\t\t\t\t- Maybe an API to set props with JS and with advanced type (like functions)\n//\t\t\t- Children\n//\t\t\t- DOM Find\n//\t\t\t- Mount / Unmount\n\n// ----------------------------------------------------------------------------- HYDRATE\n\n// TODO : Hydrate\n// TODO : Render to string or render to web components to avoid expensive hydratation ?\n\n","import { Signal, ISignal } from \"@zouloux/signal\";\nimport { _isFunction } from \"./common\";\n\n// ----------------------------------------------------------------------------- COMMON TYPES\n\nexport type TChangedHandler<GType, GReturnType = void> = ( newValue:GType, oldValue:GType) => GReturnType|Promise<GReturnType>\n\nexport type TSignalWithoutDispatch <GSignalArguments extends any[]> = Omit<ISignal<GSignalArguments>, \"dispatch\">\n\n// ----------------------------------------------------------------------------- INITIAL VALUE & SETTER\n\nexport type TInitialValue<GType> = GType | (() => GType)\nexport type TSetter<GType> = GType | ((GType) => GType)\n\nconst prepareInitialValue = <GType> ( initialValue:TInitialValue<GType> ) => (\n\t_isFunction(initialValue) ? ( initialValue as () => GType )() : initialValue as GType\n)\n\nconst executeSetter = <GType> ( currentValue:GType, setter:TSetter<GType> ):GType => (\n\t_isFunction(setter) ? (setter as ((GType) => GType))( currentValue ) : setter as GType\n)\n\n// ----------------------------------------------------------------------------- BIT\n\nexport interface IPublicBit <GType> {\n\tonChanged\t\t:TSignalWithoutDispatch<[GType, GType]>\n\tdispose \t\t() : void\n}\n\nexport interface IBit <GType> extends IPublicBit <GType> {\n\tget () : GType\n\tset ( newValue:GType ) : void\n\tdispatch ( newValue:GType, oldValue:GType ) : any|void\n}\n\n/**\n * A bit is a piece of data associated to a signal, a getter and a setter.\n * A raw bit does not dispatch the signal when set on purpose. It's meant to be\n * used by an upper function which holds dispatch as a private member.\n * @param initialValue Initial value or initial value generator.\n */\nexport function createBit <GType> ( initialValue?:TInitialValue<GType> ):IBit<GType> {\n\t// Init and store the value in this scope\n\tlet value:GType = prepareInitialValue( initialValue )\n\t// Create signal and extract dispatch method from it\n\t// So code accessing signal externally would not be able to dispatch and mess\n\tconst onChanged = Signal<[GType, GType]>()\n\tconst { dispatch } = onChanged\n\tdelete onChanged.dispatch;\n\t// Return bit API\n\treturn {\n\t\tonChanged,\n\t\tdispatch,\n\t\tget () { return value },\n\t\tset ( newValue:TSetter<GType> ) { value = executeSetter(value, newValue) },\n\t\tdispose () {\n\t\t\tonChanged.clear();\n\t\t\tvalue = null;\n\t\t}\n\t}\n}\n\n// ----------------------------------------------------------------------------- BASIC OBSERVABLE\n\nexport interface IBasicObservable <GType> extends IPublicBit <GType> {\n\treadonly value:GType\n\tset ( newValue:TInitialValue<GType> ) : void\n}\n\n/**\n * The simplest observable, holds a value a\tand dispatch when mutated.\n * No shallow check, no invalidation step, not cancellable.\n * Everything is synchronous.\n * Has a private _dispose method to destroy it from memory.\n * @param initialValue Initial value or initial value generator.\n */\n/*export function createBasicObservable <GType> ( initialValue?:TInitialValue<GType> ):IBasicObservable<GType> {\n\t// Create the bit and extract private dispatch and setter\n\t// const { get, set, dispatch, ...bit } = createBit<GType>( initialValue );\n\tconst bit = createBit<GType>( initialValue );\n\treturn {\n\t\t// ...bit,\n\t\tonChanged: bit.onChanged,\n\t\tdispose: bit.dispose,\n\t\tget value () { return bit.get() },\n\t\tset ( newValue:GType) {\n\t\t\tconst oldValue = bit.get();\n\t\t\tbit.set( newValue );\n\t\t\tbit.dispatch( newValue, oldValue )\n\t\t}\n\t}\n}*/\n\n// ----------------------------------------------------------------------------- STATE OBSERVABLE\n\nexport interface IStateObservable <GType> extends IBasicObservable <GType> {\n\tset ( newValue:TInitialValue<GType> ) : Promise<void>\n}\n\nexport function createStateObservable <GType> (\n\tinitialValue\t?:TInitialValue<GType>,\n\tbeforeChanged\t?:TChangedHandler<GType, boolean|void>\n):IStateObservable<GType> {\n\t// Create the bit and extract private dispatch and setter\n\t// TODO : IMPORTANT : Weirdly, we can destruct like this with tsc\n\t// \tget value () { return get() } will not work and always return initial value\n\t// const { get, set, dispatch, ...bit } = createBit<GType>( initialValue );\n\tconst bit = createBit<GType>( initialValue );\n\treturn {\n\t\t// ...bit,\n\t\tonChanged: bit.onChanged,\n\t\tdispose: bit.dispose,\n\t\tget value () { return bit.get() },\n\t\tasync set ( newValue:TSetter<GType> ) {\n\t\t\tconst oldValue = bit.get();\n\t\t\tnewValue = executeSetter( oldValue, newValue )\n\t\t\tbit.set( newValue );\n\t\t\tif ( beforeChanged ) {\n\t\t\t\t// isLocked = true;\n\t\t\t\tconst haltChange = await beforeChanged( newValue, oldValue )\n\t\t\t\tif ( haltChange === true ) {\n\t\t\t\t\tbit.set( oldValue );\n\t\t\t\t\t// isLocked = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// isLocked = false;\n\t\t\tbit.dispatch( newValue, oldValue );\n\t\t}\n\t}\n}\n\n// ----------------------------------------------------------------------------- ASYNC OBSERVABLE\n\nexport interface IAsyncObservable <GType> extends IStateObservable <GType> {\n\treadonly isChanging\t\t\t:boolean\n\treadonly wasAlreadyChanging\t:boolean\n}\n\nexport function createAsyncObservable <GType> (\n\tinitialValue\t?:TInitialValue<GType>,\n\tbeforeChanged\t?:TChangedHandler<GType, boolean|void>\n):IAsyncObservable<GType> {\n\t// Create the bit and extract private dispatch and setter\n\t// const { get, set, dispatch, ...bit } = createBit<GType>( initialValue );\n\tconst bit = createBit<GType>( initialValue );\n\tlet isChanging = false\n\tlet wasAlreadyChanging = false\n\treturn {\n\t\t// ...bit,\n\t\tonChanged: bit.onChanged,\n\t\tdispose: bit.dispose,\n\t\tget value () { return bit.get() },\n\t\tget isChanging () { return isChanging },\n\t\tget wasAlreadyChanging () { return wasAlreadyChanging },\n\t\tasync set ( newValue:TSetter<GType> ) {\n\t\t\t// Keep old to check changes\n\t\t\tconst oldValue = bit.get();\n\t\t\tnewValue = executeSetter( oldValue, newValue )\n\t\t\tbit.set( newValue )\n\t\t\t// Call private changed as async (may change state asynchronously)\n\t\t\tif ( beforeChanged ) {\n\t\t\t\tif ( isChanging )\n\t\t\t\t\twasAlreadyChanging = true\n\t\t\t\tisChanging = true;\n\t\t\t\tconst haltChange = await beforeChanged( newValue, oldValue )\n\t\t\t\tif ( haltChange === true ) {\n\t\t\t\t\tbit.set( oldValue )\n\t\t\t\t\tisChanging = false\n\t\t\t\t\twasAlreadyChanging = false\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tisChanging = false\n\t\t\t\tif ( wasAlreadyChanging ) {\n\t\t\t\t\twasAlreadyChanging = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Call public onChange signal with new and old values\n\t\t\tbit.dispatch( newValue, oldValue )\n\t\t}\n\t}\n}\n","export * from \"./signal.es2020.mjs\";\nexport * from \"./state-signal.es2020.mjs\";\nexport * from \"./observable.es2020.mjs\";\n","// TODO v1.1 RC\n// -> Better generic types that can leak from dispatch, without generic set at init\n// -> Better generic types which respect type order for GHP\n// ----------------------------------------------------------------------------- CLASSIC SIGNAL\nexport function Signal() {\n    // List of attached listeners\n    let _listeners = [];\n    // Remove a listener by its reference\n    const remove = (handler) => _listeners = _listeners.filter(l => l[0] !== handler);\n    // Add a listener with once and call at init parameters\n    function add(handler, once, callAtInit = false) {\n        // Add listener\n        _listeners.push([handler, once]);\n        // Call at init with parameters if callAtInit is an array of parameters\n        // Just call without parameters if callAtInit is true\n        callAtInit && handler.apply(null, Array.isArray(callAtInit) ? callAtInit : null);\n        // Return a handler which will remove this listener\n        // Very handy with React hooks like useLayoutEffect\n        return () => remove(handler);\n    }\n    // Return public API\n    return {\n        // Add and return a remove thunk\n        add(handler, callAtInit = false) {\n            return add(handler, false, callAtInit);\n        },\n        // Add once and return a remove thunk\n        once(handler) {\n            return add(handler, true);\n        },\n        remove,\n        dispatch: (...rest) => _listeners.map(listener => {\n            // Remove listener if this is a once\n            listener[1] && remove(listener[0]);\n            // Execute with parameters\n            return listener[0](...rest);\n        }),\n        clear() { _listeners = []; },\n        get listeners() { return _listeners.map(l => l[0]); }\n    };\n}\nexport default Signal;\n","import { Signal } from \"./signal.es2020.mjs\";\n// ----------------------------------------------------------------------------- STATE SIGNAL\nexport function StateSignal(_state = null, _signal = Signal()) {\n    return {\n        ..._signal,\n        get state() { return _state; },\n        // Add and return a remove thunk\n        add(handler, callAtInit = false) {\n            // Call at init will dispatch current state and not a configurable array of props\n            return _signal.add(handler, callAtInit === true ? [_state] : false);\n        },\n        // Add once and return a remove thunk\n        once(handler) {\n            return _signal.once(handler);\n        },\n        dispatch(state) {\n            _state = state;\n            return _signal.dispatch(state);\n        },\n        // Remove listeners and stored state\n        clear() {\n            _signal.clear();\n            _state = null;\n        }\n    };\n}\n","import { Signal } from \"./signal.es2020.mjs\";\nfunction prepareInitialValue(initialValue) {\n    return (typeof initialValue === \"function\"\n        ? initialValue()\n        : initialValue);\n}\n/**\n * A bit is a piece of data associated to a signal, a getter and a setter.\n * A raw bit does not dispatch the signal when set on purpose. It's meant to be\n * used by an upper function which holds dispatch as a private member.\n * @param initialValue Initial value or initial value generator.\n */\nexport function createBit(initialValue) {\n    // Init and store the value in this scope\n    let value = prepareInitialValue(initialValue);\n    // Create signal and extract dispatch method from it\n    // So code accessing signal externally would not be able to dispatch and mess\n    const onChanged = Signal();\n    const { dispatch } = onChanged;\n    onChanged.dispatch = null;\n    // Return bit API\n    return {\n        onChanged,\n        dispatch,\n        get() { return value; },\n        set(newValue) { value = newValue; },\n        dispose() {\n            onChanged.clear();\n            value = null;\n        }\n    };\n}\n/**\n * The simplest observable, holds a value a\tand dispatch when mutated.\n * No shallow check, no invalidation step, not cancellable.\n * Everything is synchronous.\n * Has a private _dispose method to destroy it from memory.\n * @param initialValue Initial value or initial value generator.\n */\nexport function createBasicObservable(initialValue) {\n    // Create the bit and extract private dispatch and setter\n    const { get, set, dispatch, ...bit } = createBit(initialValue);\n    return {\n        ...bit,\n        get value() { return get(); },\n        set(newValue) {\n            const oldValue = get();\n            set(newValue);\n            dispatch(newValue, oldValue);\n        }\n    };\n}\nexport function createStateObservable(initialValue, beforeChanged) {\n    // Create the bit and extract private dispatch and setter\n    const { get, set, dispatch, ...bit } = createBit(initialValue);\n    return {\n        ...bit,\n        get value() { return get(); },\n        async set(newValue) {\n            const oldValue = get();\n            set(newValue);\n            if (beforeChanged) {\n                // isLocked = true;\n                const haltChange = await beforeChanged(newValue, oldValue);\n                if (haltChange === true) {\n                    set(oldValue);\n                    // isLocked = false;\n                    return;\n                }\n            }\n            // isLocked = false;\n            dispatch(newValue, oldValue);\n        }\n    };\n}\nexport function createAsyncObservable(initialValue, beforeChanged) {\n    // Create the bit and extract private dispatch and setter\n    const { get, set, dispatch, ...bit } = createBit(initialValue);\n    let isChanging = false;\n    let wasAlreadyChanging = false;\n    return {\n        ...bit,\n        get value() { return get(); },\n        get isChanging() { return isChanging; },\n        get wasAlreadyChanging() { return wasAlreadyChanging; },\n        async set(newValue) {\n            // Keep old to check changes\n            const oldValue = get();\n            set(newValue);\n            // Call private changed as async (may change state asynchronously)\n            if (beforeChanged) {\n                if (isChanging)\n                    wasAlreadyChanging = true;\n                isChanging = true;\n                const haltChange = await beforeChanged(newValue, oldValue);\n                if (haltChange === true) {\n                    set(oldValue);\n                    isChanging = false;\n                    wasAlreadyChanging = false;\n                    return;\n                }\n                isChanging = false;\n                if (wasAlreadyChanging) {\n                    wasAlreadyChanging = false;\n                    return;\n                }\n            }\n            // Call public onChange signal with new and old values\n            dispatch(newValue, oldValue);\n        }\n    };\n}\n","import { VNode, VNodeBaseProps } from \"./common\";\nimport { ComponentInstance } from \"./component\";\n\n// ----------------------------------------------------------------------------- REF\n\nexport interface IRef <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n> {\n\tdom\t\t\t\t:GDom\n\tcomponent\t\t:GComponent\n}\n\nexport interface IInternalRef <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n> extends IRef {\n\tsetFromVNode\t: ( vnode:VNode<VNodeBaseProps, GComponent> ) => void\n}\n\nexport function ref <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n> ():IRef<GDom, GComponent> {\n\tconst value:IInternalRef<GDom, GComponent> = {\n\t\tcomponent: null,\n\t\tdom: null,\n\t\tsetFromVNode ( vnode:VNode<VNodeBaseProps, GComponent> ) {\n\t\t\tvalue.dom \t\t= vnode.dom as GDom;\n\t\t\tvalue.component = vnode._component as GComponent;\n\t\t}\n\t}\n\treturn value as never as IRef<GDom, GComponent>;\n}\n\n// ----------------------------------------------------------------------------- REFS\n\nexport interface IRefs <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n\t> {\n\tlist : IRef<GDom, GComponent>[]\n}\n\nexport interface IInternalRefs <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n\t> extends IRefs {\n\tsetFromVNode\t: ( index:number, vnode:VNode<VNodeBaseProps, GComponent> ) => void\n}\n\nexport function refs <\n\tGComponent extends ComponentInstance = ComponentInstance,\n\tGDom extends Element = Element,\n> ():IRefs<GDom, GComponent> {\n\tconst value:IInternalRefs<GDom, GComponent> = {\n\t\tlist: [],\n\t\tsetFromVNode ( index:number, vnode:VNode<VNodeBaseProps, GComponent> ) {\n\t\t\t// Delete\n\t\t\tif ( vnode == null ) {\n\t\t\t\tdelete value.list[ index ]\n\t\t\t\tvalue.list.length --\n\t\t\t// Update\n\t\t\t} else if ( index in value.list ) {\n\t\t\t\tvalue.list[ index ].component\t= vnode._component as GComponent;\n\t\t\t\tvalue.list[ index ].dom \t \t= vnode.dom as GDom;\n\t\t\t// Create\n\t\t\t} else {\n\t\t\t\tvalue.list[ index ] = {\n\t\t\t\t\tdom \t\t: vnode.dom as GDom,\n\t\t\t\t\tcomponent\t: vnode._component as GComponent,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn value as never as IRefs<GDom, GComponent>;\n}\n\n// FIXME : When using web components with original dom not from Reflex\n// FIXME : Move it in module web-components ?\n// export function find () {\n//\n// }","import { getHookedComponent } from \"./diff\";\nimport { _isFunction, LifecycleHandler, MountHandler } from \"./common\";\n\n// ----------------------------------------------------------------------------- MOUNT / UNMOUNT\n\nexport function mounted ( handler:MountHandler ) {\n\t// FIXME : In dev mode, maybe check if component is mounted ?\n\tgetHookedComponent()._mountHandlers.push( handler )\n}\n\nexport function unmounted ( handler:LifecycleHandler ) {\n\t// FIXME : In dev mode, maybe check if component is mounted ?\n\tgetHookedComponent()._unmountHandlers.push( handler )\n}\n\n// ----------------------------------------------------------------------------- TRACK CHANGE AFTER RENDER\n\ntype UnmountTrackHandler <GState> = (oldState:GState) => void\ntype TrackHandler <GState> = (newState:GState, oldState:GState) => UnmountTrackHandler<GState>|void\ntype DetectChanges <GState> = () => GState\n\nexport function changed <GState> ( detectChanges:DetectChanges<GState>|TrackHandler<GState>, executeHandler?:TrackHandler<GState> ) {\n\tconst component = getHookedComponent()\n\t// No executeHandler function means detectChanges has been omitted.\n\t// Do not check any change, just call executeHandler after every render.\n\tif ( !executeHandler ) {\n\t\tcomponent._renderHandlers.push( detectChanges );\n\t\treturn;\n\t}\n\t// Get first state\n\tlet state = (detectChanges as DetectChanges<GState>)()\n\t// Stored previous unmount handler\n\tlet previousUnmountHandler:LifecycleHandler\n\t// Update new state and call handlers\n\tfunction updateState ( oldState:GState ) {\n\t\t// Call previous handler with old state if it exists\n\t\tpreviousUnmountHandler && previousUnmountHandler( oldState );\n\t\t// Call executeHandler with new and old state\n\t\tconst executeResult = executeHandler( state, oldState )\n\t\t// Get previous unmount handler from return or cancel it\n\t\tpreviousUnmountHandler = (\n\t\t\t_isFunction(executeResult)\n\t\t\t? executeResult as UnmountTrackHandler<GState>\n\t\t\t: null\n\t\t)\n\t}\n\t// After component just rendered\n\tlet firstRender = true\n\tcomponent._renderHandlers.push( () => {\n\t\t// Always execute handler at first render\n\t\tif ( firstRender ) {\n\t\t\tupdateState( null );\n\t\t\tfirstRender = false;\n\t\t} else {\n\t\t\t// Otherwise, detect changes\n\t\t\tconst oldState = state;\n\t\t\tstate = ( detectChanges as DetectChanges<GState> )()\n\t\t\tif( oldState != state )\n\t\t\t\tupdateState( oldState )\n\t\t}\n\t})\n}\n"],"names":["parcelRequire","$4xUDA","$8aa3021def56a9de$export$ca000e230c0caa3e","initialValue","component","getHookedComponent","observable","$f58w7","createStateObservable","$vCAeY","invalidateComponent","_observables","push","$2rWHf","$b55a461f4688c32b$export$bb6b58cf236838ae","$b55a461f4688c32b$var$_IS_NON_DIMENSIONAL_REGEX","$b55a461f4688c32b$var$_CAPTURE_REGEX","$b55a461f4688c32b$var$_hookedComponent","$b55a461f4688c32b$export$cc5e6a61e45cbc80","$b55a461f4688c32b$var$getEventNameAndKey","name","dom","useCapture","replace","eventName","toLowerCase","slice","$b55a461f4688c32b$var$updateNodeRef","node","_ref","setFromVNode","$b55a461f4688c32b$export$a3ee0f3c7d610502","newNode","oldNode","isTextNode","type","_TEXT_NODE_TYPE_NAME","document","createTextNode","props","value","createElement","nodeValue","Object","keys","map","innerHTML","startsWith","eventKey","removeEventListener","removeAttribute","Map","addEventListener","Array","isArray","filter","v","join","trim","k","style","key","setProperty","test","$b55a461f4688c32b$var$setStyle","setAttribute","$b55a461f4688c32b$export$a9ba2108cc3d85ae","newParentNode","oldParentNode","newChildren","children","flat","oldChildren","parentDom","_keys","registerKey","c","newChildNode","$b55a461f4688c32b$export$5d8df66cb6ae1d8e","appendChild","lostIndexes","oldChild","oldParentKeys","collapseCount","i","_keep","collapsedIndex","indexOf","insertBefore","oldChildNode","$fwkQu","recursivelyUpdateMountState","removeChild","$b55a461f4688c32b$var$renderComponentNode","vnode","_component","result","_render","apply","_propsProxy","$fhfO5","cloneVNode","renderResult","_isFunction","createComponentInstance","isFactory","a","b","pure","length","every","hasOwnProperty","set","_flattenChildren","_isDirty","Element","isMounted","_renderHandlers","h","$2f7240e2d23dac03$export$ceeaf1d175e97f72","$2f7240e2d23dac03$export$e4b5d84263764130","$2f7240e2d23dac03$export$7e76fa19994d71a9","window","queueMicrotask","setTimeout","$2f7240e2d23dac03$export$3e877c6f8951d8cc","item","$2f7240e2d23dac03$export$d5baa827fb024e99","fn","$2f7240e2d23dac03$export$1eef345d23861417","$2e085b009da21c57$export$bf5c4cf060303d58","ref","$2e085b009da21c57$export$ee4f9e12c0a92a1a","$2e085b009da21c57$export$dda1d9f60106f0e9","nodeProps","child","$eae8f6c98513451a$export$e298329876cd4b79","$eae8f6c98513451a$var$createPropsProxy","_mountHandlers","_unmountHandlers","proxy","Proxy","get","target","propName","newProps","$eae8f6c98513451a$export$67406a523b38756e","doMount","handler","mountedReturn","o","dispose","$eae8f6c98513451a$export$abce5757bf99796b","$81d9b1de2eabf71b$export$b3890eb0ae9dca99","rootNode","parentElement","root","createVNode","_ROOT_NODE_TYPE_NAME","_forceArray","diffChildren","_DOM_PRIVATE_VIRTUAL_NODE_KEY","$81d9b1de2eabf71b$var$componentsToUpdate","$81d9b1de2eabf71b$var$updateDirtyComponents","diffNode","$81d9b1de2eabf71b$export$d86d0cc00dc6bc42","_microtask","$kvonT","$67ba320a79f9dae6$var$executeSetter","currentValue","setter","$67ba320a79f9dae6$export$2985e25a327f08f0","$67ba320a79f9dae6$var$prepareInitialValue","onChanged","Signal","dispatch","newValue","clear","$67ba320a79f9dae6$export$eaa260439225e231","beforeChanged","bit","async","oldValue","$67ba320a79f9dae6$export$914806c132e1f292","isChanging","wasAlreadyChanging","$6f1f8f6f71e328d0$export$8210dfe1863c478","_listeners","remove","l","add","once","callAtInit","rest","listener","listeners","$949571a43ff927b1$export$eff4d24c3ff7876e","$949571a43ff927b1$export$21666b427502ea6d","list","index","$814c192c3d6743bf$export$ccee69f0effb95fc","$814c192c3d6743bf$export$f603dcbfc05d17f4"],"version":3,"file":"index.a32a6f1c.js.map"}