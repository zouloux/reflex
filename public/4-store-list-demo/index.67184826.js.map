{"mappings":"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","sources":["demos/4-store-list-demo/index.tsx","src/store/store.ts","demos/4-store-list-demo/StoreListDemoApp.tsx","src/store/reflexStoreState.ts"],"sourcesContent":["import { h, render } from \"../../src/reflex\";\nimport { StoreListDemoApp } from \"./StoreListDemoApp\";\nimport { setReflexDebug, trackPerformances } from \"../../src/reflex/debug\";\n\n// -----------------------------------------------------------------------------\n\nsetReflexDebug( true )\n\nlet renderIndex = 0\nexport function init () {\n\tconst p = trackPerformances(\"Root rendering\")\n\trender( <StoreListDemoApp render={ init } renderIndex={ renderIndex ++ } /> , document.body );\n\tp();\n}\n\ninit();\n","import { ISignal, Signal } from \"@zouloux/signal\";\n\n/**\n * TODO :\n * - ASK ONLINE : Refactor arguments types generics\n * \t\tTODO : Clean types ! Reducers do not throw if wrong props are used in state !\n * - YEP : Able to connect it simply to cookey !\n *     - cookeyStore( store:IStore, name:string, propsToStore:{keyof Store}[] )\n * - NOPE : Separate classic and await code ?\n * - Create CancellablePromise ? Should help a lot.\n *\n * Goals :\n * - Base of next router ðŸ¥°\n * - Keep size ultra low\n * - Reflex / React / Preact compatibility.\n * - Find nice name.\n */\n\n\n// ----------------------------------------------------------------------------- STRUCT\n\n// Return types for before and after signals. Before are asynchronous, after are synchronous.\ntype TOnBeforeReturnType = Promise<any>\ntype TOnAfterReturnType = Exclude< any, Promise<any> >\ntype THandlerParameters<GState> = [ nextState:GState, oldState?:GState ]\n\n// Argument for setState, can be a state object or a function which returns a state\ntype TStateSetter <GState extends object, GArguments extends any[]> = GState | ( (state:GState) => GState )\n\n// Describes a reducer function\n// Returning state is optional\ntype TReducer <GState extends object, GArguments extends any[]> = ( state:GState, ...rest:GArguments ) => GState//|void//GState|Promise<GState>|void\n\n// List of reducers, with reducer as key, and reducer function as value\n// export type TReducers <GState extends object, GReducerActions extends string, GArguments extends any[]> = {\nexport type TReducers <GState extends object, GReducers extends object, GArguments extends any[]> = {\n\t[ reducer in keyof GReducers ] ?: TReducer <GState, GArguments>\n}\n\n// TODO : DOC\ntype TActions = { [key:string]:(...rest) => any }\n\nexport interface IStore <GState extends object, GReducers extends object = object, GArguments extends string[] = any[], GActions extends TActions = TActions>\n{\n\t/**\n\t * Retrieve current store state object\n\t */\n\tgetState\t: () => GState\n\n\t/**\n\t * Update store state and call all listeners.\n\t * Can be a function which take current state as argument and returns new state.\n\t */\n\tsetState\t: ( newState: TStateSetter<GState, GArguments> ) => void\n\n\t/**\n\t * Call a reducer.\n\t * ex : dispatch('reducerKey', 'parameter after state')\n\t * With reducers = {\n\t *     reducerKey: (s, p) => { p == 'parameter after state' }\n\t * }\n\t * @param reducer Reducer name, key of reducers.\n\t * @param rest Parameters given to reducer functions, after state argument.\n\t */\n\tdispatch\t: ( reducer:(keyof GReducers), ...rest:GArguments ) => Promise<void>\n\t// dispatch\t: ( ...rest:GArguments ) => void\n\n\t/**\n\t * Listen when state is about to be updated with setState or dispatch.\n\t * Attach only asynchronous listeners.\n\t * Listener can prevent state changes :\n\t * Any listener rejection will cause state to be not updated\n\t * Actual state change and all after listeners will be called after all before listeners.\n\t * @param listener Called when state will be updated\n\t * @returns Returns a function to remove this handler.\n\t */\n\tonBefore\t:ISignal<[GState, GState], Promise<any>>\n\n\t/**\n\t * Listen when state is updated with setState or dispatch.\n\t * Attach only synchronous listeners.\n\t * Called after all before listeners, if none of them rejected state change.\n\t * @param listener Called when state has been changed.\n\t * @returns Returns a function to remove this handler.\n\t */\n\tonAfter\t\t:ISignal<[GState, GState], Exclude<any, Promise<any>>>\n\n\t/**\n\t * When any on before signal handler prevented state change.\n\t */\n\tonCanceled\t:ISignal<[any]>\n\n\t// FIXME : Kill and override current updating state ?\n\t// onKilled\t:ISignal\n\t// kill : () => void\n\n\t/**\n\t * Lock or unlock state updates dispatches.\n\t * If lock(true) is called, any state updated through setState or dispatch\n\t * will not notify attached before or after event listeners.\n\t * When calling lock(false), all listener will be notified if state has changed.\n\t * It allows to optimize listeners notifications with this pattern :\n\t * s.lock( true )\n\t * s.dispatch(...)\n\t * s.dispatch(...)\n\t * s.setState(...)\n\t * s.lock( false ) // will notify and update components state only once here\n\t */\n\tlock\t\t: ( locked:boolean ) => Promise<void>\n\n\t/**\n\t * If store is currently manually locked\n\t */\n\treadonly locked : boolean\n\n\t/**\n\t * If store is currently dispatching an reducer asynchronously\n\t */\n\t// readonly isDispatching : boolean\n\n\t/**\n\t * If store is currently updating state asynchronously\n\t */\n\treadonly isUpdating : boolean\n\n\t// TODO DOC\n\tactions:GActions\n}\n\n\n// ----------------------------------------------------------------------------- CREATE STORE\n\nexport function createStore\n\t<\n\t\tGState extends object,\n\t\tGReducers extends TReducers<GState, GReducers, GArguments>,\n\t\tGArguments extends any[] = any[],\n\t\tGActions extends TActions = TActions\n\t\t// TODO : Typed GArguments if possible with Typescript\n\t\t// GArguments extends any[] = Partial<[\n\t\t// \tParameters<GReducers[keyof GReducers]>[1],\n\t\t// \tParameters<GReducers[keyof GReducers]>[2],\n\t\t// \tParameters<GReducers[keyof GReducers]>[3],\n\t\t// \tParameters<GReducers[keyof GReducers]>[4],\n\t\t// \tParameters<GReducers[keyof GReducers]>[5],\n\t\t// \tParameters<GReducers[keyof GReducers]>[6],\n\t\t// \tParameters<GReducers[keyof GReducers]>[7],\n\t\t// \tParameters<GReducers[keyof GReducers]>[8],\n\t\t// \tParameters<GReducers[keyof GReducers]>[9],\n\t\t// ]>,\n\t\t// GReducerActions extends string = keyof GReducers,\n\t\t// GReducers extends TReducers<GState, GReducers, GArguments>,\n\t\t// GArguments extends any[] = Partial<[\n\t\t// \t// FIXME : Refactor this, is it possible in current TS State ?\n\t\t// ]>\n\t\t// GArguments extends any[] = [\n\t\t// \tkeyof GReducers,\n\t\t// \t// ...Parameters<GReducers[keyof GReducers]>\n\t\t// ]\n\t>\n\t( state:GState = null, reducers:GReducers = null, actions ?: GActions )\n\t: IStore<GState, GReducers, GArguments, GActions>\n{\n\t// Init signals\n\tconst onBefore = Signal<THandlerParameters<GState>, TOnBeforeReturnType>()\n\tconst onAfter = Signal<THandlerParameters<GState>, TOnAfterReturnType>()\n\tconst onCanceled = Signal<[any]>()\n\t// Init properties\n\tlet isLocked = false\n\t// let _isDispatching = false\n\tlet isUpdating = false\n\tlet lockUpdated = false\n\t// Update state and call listeners\n\t// Will be synchronous if there are no asynchronous before listeners\n\tconst update = async ( newState = state ) => {\n\t\t// Dispatch are locked, just save new state\n\t\t// without dispatching before or after listeners\n\t\tif ( isLocked ) {\n\t\t\t// Remember that state has been updated while locked\n\t\t\t// To dispatch new state when unlocking\n\t\t\tlockUpdated = true\n\t\t\t// Save new state\n\t\t\tstate = newState\n\t\t\treturn\n\t\t}\n\t\t// Prevent dispatches\n\t\tisUpdating = true\n\t\t// Dispatch all asynchronous before listeners\n\t\tlet oldState = state\n\t\t// Only if we have some listeners, otherwise keep it synchronous\n\t\tif ( onBefore.listeners.length > 0 ) {\n\t\t\t// Start all promises in parallel\n\t\t\ttry {\n\t\t\t\tawait Promise.all( onBefore.listeners.map(\n\t\t\t\t\tasync l => await l( newState, oldState )\n\t\t\t\t))\n\t\t\t\t// FIXME : Add sequential option ?\n\t\t\t\t// for ( const listener of _beforeListeners )\n\t\t\t\t// \tawait listener( newState, oldState )\n\t\t\t}\n\t\t\t// Stop update if any of those middlewares trows rejection\n\t\t\tcatch ( e ) {\n\t\t\t\tonCanceled.dispatch( e )\n\t\t\t\tisUpdating = false\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t// All listeners validated state change, save new state\n\t\tstate = newState\n\t\t// Unlock right before after listeners so they can dispatch if needed\n\t\tisUpdating = false\n\t\t// Notify all after listeners that state changed\n\t\tonAfter.dispatch( newState, oldState )\n\t}\n\t// Expose public API\n\treturn {\n\t\t// Get and set state\n\t\tgetState : () => state,\n\t\tsetState : ( newState:TStateSetter<GState, GArguments> ) => update(\n\t\t\t// Call state updater if it's a function\n\t\t\t( typeof newState === 'function' ? (newState as Function)( state ) : newState )\n\t\t),\n\t\t// Dispatch reducer\n\t\tdispatch : ( reducerName:(keyof GReducers), ...rest:GArguments ) => new Promise<void>( async (resolve, reject) => {\n\t\t\t// FIXME -> Dispatch should be able to override updating state\n\t\t\t// FIXME -> And kill current onBefore listeners\n\t\t\t// Already updating state asynchronously\n\t\t\tif ( isUpdating )\n\t\t\t\treturn reject('updating')\n\t\t\t// Call reducer synchronously and update reduced data\n\t\t\tawait update( reducers[ reducerName ]( state, ...rest) as GState )\n\t\t\t// Everything has been dispatched successfully\n\t\t\tresolve()\n\t\t}),\n\t\t// Expose signals\n\t\tonBefore,\n\t\tonAfter,\n\t\tonCanceled,\n\t\t// Lock or unlock updates\n\t\tasync lock ( locked:boolean ) {\n\t\t\tisLocked = locked\n\t\t\t// If unlocking and state has changed while locked\n\t\t\tif ( !isLocked && lockUpdated ) {\n\t\t\t\t// Dispatch new state\n\t\t\t\tlockUpdated = false\n\t\t\t\tawait update( state )\n\t\t\t}\n\t\t},\n\t\t// Get locked states\n\t\tget locked () { return isLocked },\n\t\t// get isDispatching () { return _isDispatching },\n\t\tget isUpdating () { return isUpdating },\n\t\t// Expose actions\n\t\tactions\n\t}\n}","import { h, ref } from \"../../src/reflex\";\nimport { createStore } from \"../../src/store/store\";\nimport { storeState } from \"../../src/store/reflexStoreState\";\nimport { colorList, createUID, foodList, pickRandom, rand } from \"../demoHelpers\";\n\n// ----------------------------------------------------------------------------- STORE\n\ninterface IListItem {\n\tname\t:string\n\tid\t\t:string\n}\n\nconst getInitialListState = ():IListItem[] => []\n\nconst listStore = createStore( getInitialListState(), {\n\tclearList () {\n\t\treturn getInitialListState()\n\t},\n\taddItem ( state, position:\"top\"|\"bottom\", item:IListItem ) {\n\t\treturn position === \"bottom\" ? [ ...state, item ] : [ item, ...state ]\n\t},\n\tremoveItem ( state, item:IListItem ) {\n\t\treturn state.filter( currentItem => currentItem != item )\n\t},\n\tmoveItem ( state, item:IListItem, offset:number ) {\n\t\tconst index = state.indexOf( item ) + offset\n\t\tif ( index < 0 || index >= state.length ) return;\n\t\tstate = this.removeItem( state, item )\n\t\tstate.splice( index, 0, item )\n\t\treturn state\n\t},\n\taddRandomItems ( state, total:number = 0 ) {\n\t\ttotal ||= rand( 5 + state.length ) + 1\n\t\tfor ( let i = 0; i < total; ++i ) {\n\t\t\tstate = this.addItem(state, \"bottom\", {\n\t\t\t\tid: createUID(),\n\t\t\t\tname: pickRandom(colorList) + \" \" + pickRandom(foodList)\n\t\t\t})\n\t\t}\n\t\treturn state\n\t},\n\tremoveRandomItems ( state ) {\n\t\tconst total = rand( state.length ) + 1\n\t\tfor ( let i = 0; i < total; ++i ) {\n\t\t\tconst item = pickRandom( state )\n\t\t\tstate = this.removeItem( state, item )\n\t\t}\n\t\treturn state\n\t}\n})\n\n// ----------------------------------------------------------------------------- LIST ITEM\n\nconst listItemStyle = {\n\tborder\t: `1px solid black`\n}\n\ninterface IListItemProps {\n\titem\t: IListItem\n\tkey\t\t?\n}\n\nfunction ListItem ( props:IListItemProps ) {\n\t// console.log(\"ListItem\")\n\tconst { item } = props;\n\treturn <tr class=\"ListItem\" data-id={ item.id } style={ listItemStyle }>\n\t\t<td>{ item.name }</td>\n\t\t<td><button onClick={ e => listStore.dispatch(\"moveItem\", item, -1 ) }>â¬†</button></td>\n\t\t<td><button onClick={ e => listStore.dispatch(\"moveItem\", item, +1 ) }>â¬‡</button></td>\n\t\t<td><button onClick={ e => listStore.dispatch(\"removeItem\", item ) }>Remove</button></td>\n\t</tr>\n}\n\n// ----------------------------------------------------------------------------- LIST APP\n\nexport function StoreListDemoApp ( props ) {\n\n\tconst list = storeState( listStore )\n\tconst nameInput = ref<HTMLInputElement>()\n\n\tfunction controlSubmitted ( event:Event ) {\n\t\tevent.preventDefault()\n\t\tif ( !nameInput.dom.value ) return;\n\t\tlistStore.dispatch(\"addItem\", \"top\", {\n\t\t\tname: nameInput.dom.value,\n\t\t\tid: createUID()\n\t\t})\n\t\tnameInput.dom.value = \"\"\n\t}\n\n\tfunction Controls () {\n\t\treturn <div className=\"StatefulDemoApp_controls\">\n\t\t\t<table>\n\t\t\t\t<button onClick={ e => listStore.dispatch(\"addRandomItems\") }>Add random items to bottom</button>\n\t\t\t\t<button onClick={ e => listStore.dispatch(\"addRandomItems\", 1_000 ) }>Add 1.000 items to bottom</button>\n\t\t\t\t<button onClick={ e => listStore.dispatch(\"addRandomItems\", 10_000 ) }>Add 10.000 items to bottom</button>\n\t\t\t\t<button onClick={ e => listStore.dispatch(\"removeRandomItems\") }>Remove random items</button>\n\t\t\t\t<button onClick={ e => listStore.dispatch(\"clearList\") }>Clear list</button>\n\t\t\t</table>\n\t\t\t<form onSubmit={ controlSubmitted }>\n\t\t\t\t<table>\n\t\t\t\t\t<input\n\t\t\t\t\t\tid=\"StatefulDemoApp_nameInput\" ref={ nameInput }\n\t\t\t\t\t\ttype=\"text\" name=\"name\" placeholder=\"Name ...\"\n\t\t\t\t\t/>\n\t\t\t\t\t<button type=\"submit\">Add to top</button>\n\t\t\t\t</table>\n\t\t\t</form>\n\t\t</div>\n\t}\n\n\treturn () => <div class=\"StatefulDemoApp\">\n\t\t<span>Root render index : { props.renderIndex }</span>\n\t\t<Controls />\n\t\t<h3>{ list.value.length } element{ list.value.length > 1 ? 's' : '' }</h3>\n\t\t<table>\n\t\t\t{ list.value.map( item =>\n\t\t\t\t<ListItem item={ item } key={ item.id } />\n\t\t\t)}\n\t\t</table>\n\t</div>\n}\n","import { IStore } from \"./store\";\nimport { state } from \"../reflex\";\nimport { IStateObservable } from \"@zouloux/signal\";\n\n\nexport function storeState <GType extends object> ( store:IStore<GType> ) : IStateObservable<GType>\n{\n\tconst bit = state<GType>( store.getState() )\n\tstore.onAfter.add( () => bit.set( store.getState() ) )\n\t// TODO : When component is removed, remove onAfter listener\n\treturn bit;\n}\n"],"names":["$leUMy","parcelRequire","$8HdjB","$96a40833a1e192e7$export$ca97131192bad836","store","bit","state","getState","onAfter","add","set","$594053b76a28eecd$var$listStore","reducers","actions","onBefore","Signal","onCanceled","isLocked","isUpdating","lockUpdated","update","async","newState","oldState","listeners","length","Promise","all","map","l","e","dispatch","setState","reducerName","rest","resolve","reject","locked","clearList","addItem","position","item","removeItem","filter","currentItem","moveItem","offset","index","indexOf","this","splice","addRandomItems","total","$hvc62","rand","i","id","createUID","name","pickRandom","colorList","foodList","removeRandomItems","$594053b76a28eecd$var$listItemStyle","border","$594053b76a28eecd$var$ListItem","props","h","class","style","onClick","$594053b76a28eecd$export$c46037201fc34f4e","list","nameInput","ref","controlSubmitted","event","preventDefault","dom","value","Controls","className","onSubmit","type","placeholder","renderIndex","key","$3AbUl","setReflexDebug","$df30f2b2a23f0c82$var$renderIndex","$df30f2b2a23f0c82$export$2cd8252107eb640b","p","trackPerformances","render","document","body"],"version":3,"file":"index.67184826.js.map"}